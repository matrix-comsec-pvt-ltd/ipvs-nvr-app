//#################################################################################################
// FILE BRIEF
//#################################################################################################
/**
@file		NetworkConfig.c
@brief      It provides functionality to SET_CFG, GET_CFG and DFL_CFG. Request string is parsed for
            TABLE ID, INDEX ID,FIELD ID and FIELD VALUE. According to request type, updates or
            retrieves value of configuration.
*/
//#################################################################################################
// @INCLUDES
//#################################################################################################
/* Application Includes */
#include "Utils.h"
#include "NetworkConfig.h"
#include "DebugLog.h"
#include "NetworkManager.h"
#include "NetworkCommand.h"
#include "CameraDatabase.h"
#include "CameraInterface.h"

//#################################################################################################
// @DEFINES
//#################################################################################################
#define MAX_GENERAL_INDEX                   1
#define MAX_DATE_TIME_INDEX                 1
#define MAX_DST_INDEX                       1
#define MAX_LAN1_INDEX                      1
#define MAX_LAN2_INDEX                      1
#define MAX_IP_FLTR_APPLY_INDEX             1
#define MAX_IP_FLTR_INDEX                   (MAX_IP_FILTER)
#define MAX_DDNS_INDEX                      1
#define MAX_SMTP_INDEX                      1
#define MAX_FTP_INDEX                       (MAX_FTP_SERVER)
#define MAX_TCP_NOTIFY_INDEX                1
#define MAX_FILE_ACCESS_INDEX               1
#define MAX_HDD_INDEX                       1
#define MAX_MATRIX_DNS_SERVER_INDEX         1
#define MAX_USER_ACCOUNT_INDEX              (MAX_USER_ACCOUNT)
#define MAX_CAMERA_INDEX                    (MAX_CAMERA)
#define MAX_STREAM_INDEX                    (MAX_CAMERA)
#define MAX_ENBL_SCHEDL_RECORD_INDEX        (MAX_CAMERA)
#define MAX_SCHEDL_RECORD_INDEX             (MAX_CAMERA * MAX_WEEK_DAYS)
#define MAX_ALARM_RECORD_INDEX              (MAX_CAMERA)
#define MAX_PRESET_POSITION_INDEX           (MAX_CAMERA * MAX_PRESET_POSITION)
#define MAX_MAN_PRESET_TOUR_INDEX           (MAX_CAMERA)
#define MAX_AUTO_PRESET_TOUR_INDEX          (MAX_CAMERA * MAX_TOUR_NUMBER)
#define MAX_PRESET_TOUR_SCHEDL_INDEX        (MAX_CAMERA * MAX_WEEK_DAYS)
#define MAX_UPLOAD_IMAGE_INDEX              (MAX_CAMERA)
#define MAX_CAMERA_ALARM_INDEX              (MAX_CAMERA * MAX_CAMERA_ALARM)
#define MAX_CAMERA_E_A_INDEX                (MAX_CAMERA * MAX_CAMERA_EVENT)
#define MAX_CAMERA_E_A_SCHEDL_INDEX         (MAX_CAMERA * MAX_CAMERA_EVENT * MAX_WEEK_DAYS)
#define MAX_SYSTEM_SENSOR_INDEX             (MAX_SENSOR)
#define MAX_SYSTEM_ALARM_INDEX              (MAX_ALARM)
#define MAX_STORAGE_INDEX                   1
#define MAX_SCHEDL_BACKUP_INDEX             1
#define MAX_MAN_BACKUP_INDEX                1
#define MAX_SENSOR_E_A_INDEX                (MAX_SENSOR)
#define MAX_SENSOR_E_A_SCHEDL_INDEX         (MAX_SENSOR * MAX_WEEK_DAYS)
#define MAX_SYSTEM_E_A_INDEX                (MAX_SYSTEM_EVENT)
#define MAX_COSEC_REC_CFG_INDEX             (MAX_CAMERA)
#define MAX_DEFAULT_ROUTING_INDEX           1
#define MAX_STATIC_ROUTING_INDEX            (MAX_STATIC_ROUTING_ENTRY)
#define MAX_BROAD_BAND_PRO_INDEX            1
#define MAX_BROAD_BAND_INDEX                (MAX_BROADBAND_PROFILE)
#define MAX_SMS_INDEX                       1
#define MAX_MANUAL_RECORD_INDEX             (MAX_CAMERA)
#define MAX_NETWORK_DRIVE_INDEX             (MAX_NW_DRIVE)
#define MAX_SCHEDL_INDEX                    (MAX_CAMERA)
#define MAX_SCHEDL_SCHD_INDEX               (MAX_CAMERA)
#define MAX_LOGIN_POLICY_INDEX              1
#define MAX_IP_CAMERA_INDEX                 (MAX_CAMERA)
#define MAX_AUDIO_OUT_INDEX                 1
#define MAX_P2P_CONFIG_INDEX                1
#define MAX_IMG_SETTING_INDEX               (MAX_CAMERA)
#define MAX_DHCP_SERVER_INDEX               1
#define MAX_FIRMWARE_MANAGEMENT_INDEX       1
#define MAX_FCM_PUSH_NOTIFICATION_INDEX     FCM_PUSH_NOTIFY_DEVICES_MAX
#define MAX_PASSWORD_RECOVERY_INDEX         (MAX_USER_ACCOUNT)
#define MAX_STORAGE_ALLOCATION_INDEX        1
#define GET_MAX_INDEX(maxIdx, maxSubIdx)	(maxIdx * maxSubIdx)

#define PRINT_INT(value) 	outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%d%c%u%c", OUR_TO_CLIENT_INDEX(fieldLoop), FVS, value, FSP);
#define PRINT_INT64(value) 	outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%d%c%llu%c", OUR_TO_CLIENT_INDEX(fieldLoop), FVS, value, FSP);
#define PRINT_CHAR(value) 	outLen += sprintf(respStringPtr + outLen, "%d%c%c%c", OUR_TO_CLIENT_INDEX(fieldLoop), FVS, value, FSP);
#define PRINT_STRING(value) outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%d%c%s%c", OUR_TO_CLIENT_INDEX(fieldLoop), FVS, value, FSP);
#define PRINT_TIME(value)	outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%d%c%02d%02d%c", OUR_TO_CLIENT_INDEX(fieldLoop), FVS, value.hour, value.minute, FSP);
#define PRINT_EOI 			outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);

//#################################################################################################
// @DATA TYPES
//#################################################################################################
typedef enum
{
	GET_TABLE_ID = 0,
	GET_FROM_INDEX_ID,
	GET_TO_INDEX_ID,
	GET_FROM_FIELD_ID,
	GET_TO_FIELD_ID,
	MAX_GET_CMD_PARAM

}GET_CMD_PARAM_STR_e;

typedef enum
{
	DEF_TABLE_ID = 0,
	DEF_FROM_INDEX_ID,
	DEF_TO_INDEX_ID,
	MAX_DEF_CMD_PARAM

}DEF_CMD_PARAM_STR_e;

typedef enum
{
	GEN_CFG_DEVICE_NAME,
	GEN_CFG_FILE_RECORD_DURATION,
	GEN_CFG_AUTO_LOGOUT_DURATION,
	GEN_CFG_AUTO_POWER_ON,
	GEN_CFG_HTTP_PORT,
	GEN_CFG_TCP_PORT,
	GEN_CFG_RTP_PORT_START,
	GEN_CFG_RTP_PORT_END,
	GEN_CFG_ONVIF_PORT,
	GEN_CFG_DEVICE_ID,
	GEN_CFG_VIDEO_SYSTEM_TYPE,
	GEN_CFG_COSEC_RECORDING,
	GEN_CFG_DATE_FORMAT,
	GEN_CFG_TIME_FORMAT,
	GEN_CFG_RECORD_FORMAT,
	GEN_CFG_ANALOG_CAM_NO,
	GEN_CFG_IP_CAM_NO,
	GEN_CFG_AUTO_CONFIG_FLAG,
	GEN_CFG_IP_RETAIN_FLAG,
	GEN_CFG_AUTO_CONFIG_START_IP,
	GEN_CFG_AUTO_CONFIG_END_IP,
	GEN_CFG_PROFILR_RETAIN_FLAG,

	GEN_CFG_MAIN_STREAM_VIDEO_ENCODING,
	GEN_CFG_MAIN_STREAM_FRAMERATE,
	GEN_CFG_MAIN_STREAM_RESOLUTION,
	GEN_CFG_MAIN_STREAM_BITRATE_MODE,
	GEN_CFG_MAIN_STREAM_BITRATE_VALUE,
	GEN_CFG_MAIN_STREAM_QUALITY,
	GEN_CFG_MAIN_STREAM_GOP,
	GEN_CFG_MAIN_STREAM_ENABLE_AUDIO,

	GEN_CFG_SUB_STREAM_VIDEO_ENCODING,
	GEN_CFG_SUB_STREAM_FRAMERATE,
	GEN_CFG_SUB_STREAM_RESOLUTION,
	GEN_CFG_SUB_STREAM_BITRATE_MODE,
	GEN_CFG_SUB_STREAM_BITRATE_VALUE,
	GEN_CFG_SUB_STREAM_QUALITY,
	GEN_CFG_SUB_STREAM_GOP,
	GENCFG_SUB_STREAM_ENABLE_AUDIO,

	GEN_CFG_DI_ACTIVE_FLAG,
	GEN_CFG_DI_SERVER_IP,
	GEN_CFG_DI_SERVER_PORT,
	GEN_CFG_AUTO_REC_FAIL_ALERT,
	GEN_CFG_VIDEO_POPUP_DURATION,
	GEN_CFG_PRE_VIDEO_LOSS_DURATION,

	GEN_CFG_USER_NAME,
	GEN_CFG_PASSWORD,

	GEN_CFG_START_LIVE_VIEW_FLAG,
	GEN_CFG_FORWARDED_TCP_PORT,
	GEN_CFG_AUTO_ADD_CAM_FLAG,
	GEN_CFG_AUTO_ADD_CAM_TCP_PORT,
	GEN_CFG_POLL_DURATION,
	GEN_CFG_POLL_INTERVAL,
	GEN_CFG_NET_ACCELERATION,
	MAX_GEN_CFG_FIELD

}GEN_CFG_FIELD_e;

typedef enum
{
	DATE_TIME_CFG_TIMEZONE,
	DATE_TIME_CFG_UPDATE_MODE,
	DATE_TIME_CFG_NTP_SERVER,
	DATE_TIME_CFG_USER_DEFINED_SERVER,
	DATE_TIME_CFG_UPDATE_INTERVAL,
	DATE_TIME_CFG_AUTO_UPDATE_REGIONAL,
    DATE_TIME_CFG_AUTO_SYNC_TIMEZONE,
    DATE_TIME_CFG_SET_UTC_TIME,
	MAX_DATE_TIME_CFG_FIELD

}DATE_TIME_CFG_FIELD_e;

typedef enum
{
	DST_CFG_DST,
	DST_CFG_FORWARD_CLK_DAY_MONTH,
	DST_CFG_FORWARD_CLK_DAY_WEEK,
	DST_CFG_FORWARD_CLK_DAY_WEEKDAY,
	DST_CFG_FORWARD_CLK_INSTATNCE,
	DST_CFG_REVERSE_CLK_DAY_MONTH,
	DST_CFG_REVERSE_CLK_DAY_WEEK,
	DST_CFG_REVERSE_CLK_DAY_WEEKDAY,
	DST_CFG_REVERSE_CLK_INSTATNCE,
	DST_CFG_PERIOD,
	MAX_DST_CFG_FIELD

}DST_CFG_FILED_e;

typedef enum
{
    LAN_1_CFG_IPV4_ASSIGN_MODE,
    LAN_1_CFG_LAN_IPV4_ADDRESS,
    LAN_1_CFG_LAN_IPV4_SUBNET_MASK,
    LAN_1_CFG_LAN_IPV4_GATEWAY,
	LAN_1_CFG_PPPOE_USERNAME,
	LAN_1_CFG_PPPOE_PASSWORD,
    LAN_1_CFG_DNSV4_MODE,
    LAN_1_CFG_DNSV4_PRIMARY_ADDRESS,
    LAN_1_CFG_DNSV4_SECONDARY_ADDRESS,
    LAN_1_CFG_ADDR_MODE,
    LAN_1_CFG_IPV6_ASSIGN_MODE,
    LAN_1_CFG_LAN_IPV6_ADDRESS,
    LAN_1_CFG_LAN_PREFIX_LEN,
    LAN_1_CFG_LAN_IPV6_GATEWAY,
    LAN_1_CFG_DNSV6_MODE,
    LAN_1_CFG_DNSV6_PRIMARY_ADDRESS,
    LAN_1_CFG_DNSV6_SECONDARY_ADDRESS,
	MAX_LAN_1_CFG_FIELD,

}LAN_1_CFG_FIELD_e;

typedef enum
{
    LAN_2_CFG_IPV4_ADDRESS,
    LAN_2_CFG_IPV4_SUBNET_MASK,
    LAN_2_CFG_IPV4_GATEWAY,
    LAN_2_CFG_ADDR_MODE,
    LAN_2_CFG_LAN_IPV6_ADDRESS,
    LAN_2_CFG_LAN_PREFIX_LEN,
    LAN_2_CFG_LAN_IPV6_GATEWAY,
	MAX_LAN_2_CFG_FIELD,

}LAN_2_CFG_FIELD_e;

typedef enum
{
	IP_FILTER_ENABLE_CFG_IP_FILTER,
	IP_FILTER_ENABLE_CFG_FILTER_MODE,
	MAX_IP_FILTER_ENABLE_CFG_FIELD

}IP_FILTER_ENABLE_CFG_FIELD_e;

typedef enum
{
	IP_FILTER_CFG_START_ADDRESS,
	IP_FILTER_CFG_END_ADDRESS,
	MAX_IP_FILTER_CFG_FIELD

}IP_FILTER_CFG_FILED_e;

typedef enum
{
	DDNS_CFG_DDNS,
	DDNS_CFG_SERVER,
	DDNS_CFG_USERNAME,
	DDNS_CFG_PASSWORD,
	DDNS_CFG_HOSTNAME,
	DDNS_CFG_UPDATE_DURATION,
	MAX_DDNS_CFG_FIELD

}DDNS_CFG_FIELD_e;

typedef enum
{
	SMTP_CFG_SMTP,
	SMTP_CFG_SERVER,
	SMTP_CFG_SERVER_PORT,
	SMTP_CFG_USERNAME,
	SMTP_CFG_PASSWORD,
	SMTP_CFG_SENDOR_ADDRESS,
	SMTP_CFG_SSL,
	MAX_SMTP_CFG_FIELD

}SMTP_CFG_FIELD_e;

typedef enum
{
	FTP_UPLOAD_CFG_FTP,
	FTP_UPLOAD_CFG_SERVER,
	FTP_UPLOAD_CFG_SERVER_PORT,
	FTP_UPLOAD_CFG_USERNAME,
	FTP_UPLOAD_CFG_PASSWORD,
	FTP_UPLOAD_CFG_UPLOAD_PATH,
	MAX_FTP_UPLOAD_CFG_FIELD

}FTP_UPLOAD_CFG_FIELD_e;

typedef enum
{
	TCP_NOTIFY_CFG_TCP_NOTIFY,
	TCP_NOTIFY_CFG_SERVER,
	TCP_NOTIFY_CFG_PORT,
	MAX_TCP_NOTIFY_CFG_FIELD

}TCP_NOTIFY_CFG_FIELD_e;

typedef enum
{
	FILE_ACCESS_CFG_FTP_ACCESS,
	FILE_ACCESS_CFG_FTP_PORT,
	MAX_FILE_ACCESS_CFG_FIELD

}FILE_ACCESS_CFG_FILED_e;

typedef enum
{
	HDD_CFG_MODE,
	HDD_CFG_RECORD_DISK,
	MAX_HDD_CFG_FIELD

}HDD_CFG_FIELD_e;

typedef enum
{
	MATRIX_DNS_SERVER_CFG_EN_MAC_CLIENT,
	MATRIX_DNS_SERVER_CFG_HOST_NAME,
	MATRIX_DNS_SERVER_CFG_PORT,
	MAX_MATRIX_DNS_SERVER_CFG_FIELD

}MATRIX_DNS_SERVER_CFG_FIELD_e;

typedef enum
{
	USER_ACCOUNT_CFG_USERNAME,
	USER_ACCOUNT_CFG_USERGROUP,
	USER_ACCOUNT_CFG_PASSWORD,
	USER_ACCOUNT_CFG_USERSTATUS,
	USER_ACCOUNT_CFG_MULTILOGIN,
	USER_ACCOUNT_CFG_LOGINSESSION_LIMIT_DURATION,
    USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START,
    USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_END = (USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START + MAX_CAMERA_CONFIG - 1),
	USER_ACCOUNT_CFG_SYNC_WITH_NET_DEVICES,
	USER_ACCOUNT_PREFERRED_LANGUAGE,
    USER_ACCOUNT_CFG_ALLOW_PUSH_NOTIFICATION,
	MAX_USER_ACCOUNT_CFG_FIELD,

}USER_ACCOUNT_CFG_FIELD_e;

typedef enum
{
	CAMERA_CFG_CAMERA,
	CAMERA_CFG_NAME,
	CAMERA_CFG_TYPE,
	CAMERA_CFG_LOG_MOTION_EVENTS,
	CAMERA_CFG_MOTION_REDETECTION_DELAY,
	CAMERA_CFG_CAMERA_NAME_POS,
	CAMERA_CFG_STATUS_POS,
	CAMERA_CFG_DATETIME_OVERLAY,
	CAMERA_CFG_DATETIME_POS,
    CAMERA_CFG_TEXT_OVERLAY_STATUS,
    CAMERA_CFG_TEXT_OVERLAY_0_NAME,
    CAMERA_CFG_TEXT_OVERLAY_0_POSITION,
	CAMERA_CFG_MOBILE_NUM,
    CAMERA_CFG_PRIVACY_MASK_STATUS,
	CAMERA_CFG_MOTION_STATUS,
	CAMERA_CFG_RECORDING_STREAM,
    CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_START,
    CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_END = CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
    CAMERA_CFG_TEXT_OVERLAY_1_NAME,
    CAMERA_CFG_TEXT_OVERLAY_1_POSITION,
    CAMERA_CFG_TEXT_OVERLAY_2_NAME,
    CAMERA_CFG_TEXT_OVERLAY_2_POSITION,
    CAMERA_CFG_TEXT_OVERLAY_3_NAME,
    CAMERA_CFG_TEXT_OVERLAY_3_POSITION,
    CAMERA_CFG_TEXT_OVERLAY_4_NAME,
    CAMERA_CFG_TEXT_OVERLAY_4_POSITION,
    CAMERA_CFG_TEXT_OVERLAY_5_NAME,
    CAMERA_CFG_TEXT_OVERLAY_5_POSITION,

    /* When Max field reach to 52 then remove dummy field, It is added for backward compatibility for UI and cascading.
     * Older UI requests 1 to 52 fields to get the Camera Name, Position & Type, OSD Info, Text Overlay Info
     * but remaining fields are not used by UI. If you modify any of this field, you have to check compatibility with cascading */
    CAMERA_CFG_DUMMY_FIELD,
    MAX_CAMERA_CFG_FIELD = 52,

}CAMERA_CFG_FIELD_e;

typedef enum
{
	STREAM_CFG_MAIN_STREAM_VIDEO_ENCODING,
	STREAM_CFG_MAIN_STREAM_RESOLUTION,
	STREAM_CFG_MAIN_STREAM_FRAMERATE,
	STREAM_CFG_MAIN_STREAM_QUALITY,
	STREAM_CFG_MAIN_STREAM_ENABLE_AUDIO,
	STREAM_CFG_MAIN_STREAM_BITRATE_MODE,
	STREAM_CFG_MAIN_STREAM_BITRATE_VALUE,
	STREAM_CFG_MAIN_STREAM_GOP,
	STREAM_CFG_SUB_STREAM_VIDEO_ENCODING,
	STREAM_CFG_SUB_STREAM_RESOLUTION,
	STREAM_CFG_SUB_STREAM_FRAMERATE,
	STREAM_CFG_SUB_STREAM_QUALITY,
	STREAM_CFG_SUB_STREAM_ENABLE_AUDIO,
	STREAM_CFG_SUB_STREAM_BITRATE_MODE,
	STREAM_CFG_SUB_STREAM_BITRATE_VALUE,
	STREAM_CFG_SUB_STREAM_GOP,
	STREAM_CFG_MAIN_STREAM_PROFILE,
	STREAM_CFG_SUB_STREAM_PROFILE,
    STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_START,
    STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_END = STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
    STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_START,
    STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_END = STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_STREAM_CFG_FIELD

}STREAM_CFG_FIELD_e;

//Table-19 schedule record Enum
typedef enum
{
    SHED_RECDNG_ENABLE,
    SHED_RECDNG_COPY_TO_CAMERA_START,
    SHED_RECDNG_COPY_TO_CAMERA_END = SHED_RECDNG_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_SCHED_RECD_CFG_FIELD1

}SCHED_RECD_CFG_FIELD1_e;

//Table-20 schedule record Enum
typedef enum
{
	RECD_ENTIRE_DAY,
	PERIOD0_START_TIME,
	PERIOD0_END_TIME,
	PERIOD1_START_TIME,
	PERIOD1_END_TIME,
	PERIOD2_START_TIME,
	PERIOD2_END_TIME,
	PERIOD3_START_TIME,
	PERIOD3_END_TIME,
	PERIOD4_START_TIME,
	PERIOD4_END_TIME,
	PERIOD5_START_TIME,
	PERIOD5_END_TIME,
    PERIOD_COPY_TO_CAMERA_START,
    PERIOD_COPY_TO_CAMERA_END = PERIOD_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_SCHED_RECD_CFG_FIELD2

}SCHED_RECD_CFG_FIELD2_e;

typedef enum
{
    ALARM_RECORD_CFG_PRE_RECORD_TIME,
	ALARM_RECORD_CFG_POST_RECORD_TIME,
    ALARM_RECORD_CFG_COPY_TO_CAMERA_START,
    ALARM_RECORD_CFG_COPY_TO_CAMERA_END = ALARM_RECORD_CFG_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_ALARM_RECORD_CFG_FIELD

}ALARM_RECORD_CFG_FIELD_e;

typedef enum
{
	PRESET_POSITION_CFG_NAME,
	MAX_PRESET_POSITION_CFG_FIELD

}PRESET_POSITION_CFG_FIELD_e;

//Table-23 manual tour Enum
typedef enum
{
	MANUAL_TOUR_OVER_RIDE,
	MANUAL_TOUR,
	ACTIVE_TOUR_OVER_RIDE,
	MAX_PRESET_TOUR_CONFIG_FIELD1

}PRESET_TOUR_CONFIG_FIELD1_e;

//Table-24 ptz tour Enum
typedef enum
{
	TOUR_NAME,
	TOUR_PATTERN,
	PAUSE_BETWEEN_TOUR,
	TOUR_PTZ0_PRESET_POSITION,
	TOUR_PTZ0_VIEW_TIME,
	TOUR_PTZ1_PRESET_POSITION,
	TOUR_PTZ1_VIEW_TIME,
	TOUR_PTZ2_PRESET_POSITION,
	TOUR_PTZ2_VIEW_TIME,
	TOUR_PTZ3_PRESET_POSITION,
	TOUR_PTZ3_VIEW_TIME,
	TOUR_PTZ4_PRESET_POSITION,
	TOUR_PTZ4_VIEW_TIME,
	TOUR_PTZ5_PRESET_POSITION,
	TOUR_PTZ5_VIEW_TIME,
	TOUR_PTZ6_PRESET_POSITION,
	TOUR_PTZ6_VIEW_TIME,
	TOUR_PTZ7_PRESET_POSITION,
	TOUR_PTZ7_VIEW_TIME,
	TOUR_PTZ8_PRESET_POSITION,
	TOUR_PTZ8_VIEW_TIME,
	TOUR_PTZ9_PRESET_POSITION,
	TOUR_PTZ9_VIEW_TIME,
	TOUR_PTZ10_PRESET_POSITION,
	TOUR_PTZ10_VIEW_TIME,
	TOUR_PTZ11_PRESET_POSITION,
	TOUR_PTZ11_VIEW_TIME,
	TOUR_PTZ12_PRESET_POSITION,
	TOUR_PTZ12_VIEW_TIME,
	TOUR_PTZ13_PRESET_POSITION,
	TOUR_PTZ13_VIEW_TIME,
	TOUR_PTZ14_PRESET_POSITION,
	TOUR_PTZ14_VIEW_TIME,
	TOUR_PTZ15_PRESET_POSITION,
	TOUR_PTZ15_VIEW_TIME,
	TOUR_PTZ16_PRESET_POSITION,
	TOUR_PTZ16_VIEW_TIME,
	TOUR_PTZ17_PRESET_POSITION,
	TOUR_PTZ17_VIEW_TIME,
	TOUR_PTZ18_PRESET_POSITION,
	TOUR_PTZ18_VIEW_TIME,
	TOUR_PTZ19_PRESET_POSITION,
	TOUR_PTZ19_VIEW_TIME,
	TOUR_PTZ20_PRESET_POSITION,
	TOUR_PTZ20_VIEW_TIME,
	TOUR_PTZ21_PRESET_POSITION,
	TOUR_PTZ21_VIEW_TIME,
	TOUR_PTZ22_PRESET_POSITION,
	TOUR_PTZ22_VIEW_TIME,
	TOUR_PTZ23_PRESET_POSITION,
	TOUR_PTZ23_VIEW_TIME,
	TOUR_PTZ24_PRESET_POSITION,
	TOUR_PTZ24_VIEW_TIME,
	TOUR_PTZ25_PRESET_POSITION,
	TOUR_PTZ25_VIEW_TIME,
	TOUR_PTZ26_PRESET_POSITION,
	TOUR_PTZ26_VIEW_TIME,
	TOUR_PTZ27_PRESET_POSITION,
	TOUR_PTZ27_VIEW_TIME,
	TOUR_PTZ28_PRESET_POSITION,
	TOUR_PTZ28_VIEW_TIME,
	TOUR_PTZ29_PRESET_POSITION,
	TOUR_PTZ29_VIEW_TIME,
	TOUR_PTZ30_PRESET_POSITION,
	TOUR_PTZ30_VIEW_TIME,
	TOUR_PTZ31_PRESET_POSITION,
	TOUR_PTZ31_VIEW_TIME,
	TOUR_PTZ32_PRESET_POSITION,
	TOUR_PTZ32_VIEW_TIME,
	TOUR_PTZ33_PRESET_POSITION,
	TOUR_PTZ33_VIEW_TIME,
	TOUR_PTZ34_PRESET_POSITION,
	TOUR_PTZ34_VIEW_TIME,
	TOUR_PTZ35_PRESET_POSITION,
	TOUR_PTZ35_VIEW_TIME,
	TOUR_PTZ36_PRESET_POSITION,
	TOUR_PTZ36_VIEW_TIME,
	TOUR_PTZ37_PRESET_POSITION,
	TOUR_PTZ37_VIEW_TIME,
	TOUR_PTZ38_PRESET_POSITION,
	TOUR_PTZ38_VIEW_TIME,
	TOUR_PTZ39_PRESET_POSITION,
	TOUR_PTZ39_VIEW_TIME,
	MAX_PRESET_TOUR_CONFIG_FIELD2

}PRESET_TOUR_CONFIG_FIELD2_e;

//Table-25 Enum
typedef enum
{
	PRESET_TOUR_ENTIRE_DAY,
	PRESET_TOUR_NUM,
	PRESET_TOUR_SCHED0_START_TIME,
	PRESET_TOUR_SCHED0_END_TIME,
	PRESET_TOUR_SCHED0_TOUR_NUM,
	PRESET_TOUR_SCHED1_START_TIME,
	PRESET_TOUR_SCHED1_END_TIME,
	PRESET_TOUR_SCHED1_TOUR_NUM,
	MAX_PRESET_TOUR_SCHED_CONFIG_FIELD

}PRESET_TOUR_SCHED_CFG_e;

//Table-26 sensor configuration Enum
typedef enum
{
	SENSOR_DETECT,
	SENSOR_NAME,
	SENSOR_MODE,
	SENSOR_DEBOUNCE_TIME,
	MAX_SENSOR_CONFIG_FIELD

}SENSOR_CFG_e;

//Table-27 system alarm Enum
typedef enum
{
	SYS_ALM_OUTPUT,
	SYS_ALM_NAME,
	SYS_ALM_MODE,
	SYS_ALM_PULSE_PERIOD,
	MAX_SYS_ALM_CFG_FIELD

}SYS_ALM_CFG_e;

//Table-28 Image Upload Configuration Enum
typedef enum
{
	IMG_UPLD_RESOLUTION,
	IMG_UPLD_LOCATION,
	IMG_UPLD_EMAIL_ADDR,
	IMG_UPLD_EMAIL_SUBJECT,
	IMG_UPLD_EMAIL_MESSAGE,
	IMG_UPLD_RATE,
	MAX_IMG_UPLD_CFG_FIELD

}IMG_UPLD_CFG_e;

//Table-29 Storage Configuration Enum

typedef enum
{
	STORAGE_HDD_FULL_ACTION_MODE,
	STORAGE_HDD_FULL_PERCENTAGE_CLEAN,
	STORAGE_RECORD_RETENTATION_STATUS,
	STORAGE_RECORD_RETENTATION_TYPE,
	STORAGE_DRIVE_WISE_RECORD_CLEANUP_DAYS,
	STORAGE_STRG_ALT_ALERT,
	STORAGE_STRG_ALT_RMNG_CPCTY,
	STORAGE_BACKUP_RETENTATION_STATUS,
    STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START,
    STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_END = (STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START + MAX_CAMERA_CONFIG - 1),
    STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START,
    STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_END = (STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START + MAX_CAMERA_CONFIG - 1),
	MAX_STORAGE_CFG_FIELD

}STORAGE_CFG_e;

//Table-30 Shedule Backup Configuration Enum
typedef enum
{
	SCHEDULE_BACKUP_BACKUP,
	SCHEDULE_BACKUP_MODE,
	SCHEDULE_BACKUP_EVERY_HOUR_MODE,
	SCHEDULE_BACKUP_EVERY_DAY_BKUP_HOUR,
	SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_DAYS,
	SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_HOUR,
    SCHEDULE_BACKUP_CAMERA_MASK_START,
    SCHEDULE_BACKUP_CAMERA_MASK_END = SCHEDULE_BACKUP_CAMERA_MASK_START + CAMERA_MASK_MAX - 1,
	SCHEDULE_BACKUP_BKUP_LOCATION,
	MAX_SCHEDULE_BACKUP_CFG_FIELD

}SCHEDULE_BACKUP_CFG_e;

//Table-31 Manual Backup Configuration Enum
typedef enum
{
	MANUAL_BACKUP_ENABLE,
	MANUAL_BACKUP_DURATION,
    MANUAL_BACKUP_CAMERA_MASK_START,
    MANUAL_BACKUP_CAMERA_MASK_END = MANUAL_BACKUP_CAMERA_MASK_START + CAMERA_MASK_MAX - 1,
	MANUAL_BACKUP_LOCATION,
	MAX_MANUAL_BACKUP_CFG_FIELD

}MANUAL_BACKUP_CFG_e;

//Table-32 Camera Event Configuration for field1 Enum
typedef enum
{
	EVENT_ACTION_ENABLE,
    EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START,
    EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_END = EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START + CAMERA_MASK_MAX - 1,
    EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START,
    EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_END = EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START + CAMERA_MASK_MAX - 1,
	EVENT_ACTION_PARAMETER_EMAIL_ADDR,
	EVENT_ACTION_PARAMETER_EMAIL_SUBJ,
	EVENT_ACTION_PARAMETER_EMAIL_MSG,
	EVENT_ACTION_SEND_TCP,
	EVENT_ACTION_SMS_MOB_NUM1,
	EVENT_ACTION_SMS_MOB_NUM2,
	EVENT_ACTION_SMS_MESSAGE,
	EVENT_ACTION_GOTO_PRESET_CAM_NUM,
	EVENT_ACTION_GOTO_PRESET_PRESET_POS,
	EVENT_ACTION_SYS_ALM_OUTPUT0,
	EVENT_ACTION_SYS_ALM_OUTPUT1,
	EVENT_ACTION_SYS_ALM_OUTPUT2,
	EVENT_ACTION_SYS_ALM_OUTPUT3,
	EVENT_ACTION_CAM_ALM_CAM_NUM,
	EVENT_ACTION_CAM_ALM_ALM0,
	EVENT_ACTION_CAM_ALM_ALM1,
	EVENT_ACTION_CAM_ALM_ALM2,
    EVENT_ACTION_BITGRP_START,
    EVENT_ACTION_BITGRP_END = EVENT_ACTION_BITGRP_START + CAMERA_MASK_MAX - 1,
	MAX_CAMERA_EVENT_CFG_FIELD1

}CAMERA_EVENT_CFG_FIELD1_e;

//Table-33 Camera Event Configuration for field2 Enum
typedef enum
{
	EVENT_ACTION_WEEKSCHED_ENTIRE_DAY,
	EVENT_ACTION_WEEKSCHED_ENTIRE_DAY_ACTION,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL0_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL0_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL0_SCHED_ACT_BITFIELD,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL1_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL1_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL1_SCHED_ACT_BITFIELD,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL2_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL2_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL2_SCHED_ACT_BITFIELD,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL3_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL3_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL3_SCHED_ACT_BITFIELD,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL4_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL4_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL4_SCHED_ACT_BITFIELD,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL5_STRT_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL5_END_TIME,
	EVENT_ACTION_WEEKSCHED_ACT_CTRL5_SCHED_ACT_BITFIELD,
	MAX_CAMERA_EVENT_CFG_FIELD2

}CAMERA_EVENT_CFG_FIELD2_e;

//Table-37 Cosec Record
typedef enum
{
	COSEC_REC_ENABLE,
	COSEC_PRE_REC_DURATION,
    COSEC_REC_COPY_TO_CAMERA_START,
    COSEC_REC_COPY_TO_CAMERA_END = COSEC_REC_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_COSEC_REC_FIELD

}COSEC_REC_FIELD_e;

//Table-38 camera alarm  Configuration Enum
typedef enum
{
	CAM_ALM_ACTV_MODE,
	CAM_ALM_ACTV_TIME,
	MAX_CAM_ALM_CFG_FIELD

}CAM_ALM_CFG_e;

//Table-39 default static routing Enum
typedef enum
{
	STAT_ROUTE_DFLT_PORT,
	MAX_STAT_ROUTE_FIELD1

}STAT_ROUTE_CFG_FIELD1_e;

//Table-40 static routing Enum
typedef enum
{
	STAT_ROUTE_NW_ADDR,
	STAT_ROUTE_SUBNET_MASK,
	STAT_ROUTE_ROUTE_PORT,
	MAX_STAT_ROUTE_FIELD2

}STAT_ROUTE_CFG_FIELD2_e;

//Table-41 broad band profile Enum
typedef enum
{
	BRD_BND_ACTV_PROFILE,
	MAX_BRD_BND_CFG_FIELD1

}BRD_BND_CFG_FIELD1_e;

//Table-41 broad band profile Enum
typedef enum
{
	BRD_BND_PROFILE_NAME,
	BRD_BND_DIAL_NUM,
	BRD_BND_USR_NAME,
	BRD_BND_USR_PWD,
	BRD_BND_APN,
	MAX_BRD_BND_CFG_FIELD2

}BRD_BND_CFG_FIELD2_e;

//Table-43 Sms Configuration Enum
typedef enum
{
	SMS_MODE,
	SMS_SERVER,
	SMS_USER_NAME,
	SMS_USER_PWD,
	SMS_SENDER_ID,
	SMS_SEND_AS_FLASH,
	MAX_SMS_CFG_FIELD

}SMS_CFG_e;

//Table-44 Manual Record Configuration Enum
typedef enum
{
	MAN_RECORD_STATUS,
    MANUAL_COPY_TO_CAMERA_START,
    MANUAL_COPY_TO_CAMERA_END = MANUAL_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_MAN_RECORD_CFG_FIELD

}MAN_RECORD_CFG_e;

//Table-45 network drive Configuration Enum
typedef enum
{
	NW_DRIVE_ENABLE,
	NW_DRIVE_NAME,
	NW_DRIVE_IP_ADDR,
	NW_DRIVE_USR_NAME,
	NW_DRIVE_USR_PWD,
	NW_DRIVE_FILE_SYS,
	NW_DRIVE_DFLT_FOLDER,
	MAX_NW_DRIVE_CFG_FIELD

}NW_DRIVE_CFG_e;

// Table-46 Ip Camera Configuration Enum
typedef enum
{
	IP_CAMERA_CFG_BRAND,
	IP_CAMERA_CFG_MODEL,
	IP_CAMERA_CFG_URL,
	IP_CAMERA_CFG_ADDRESS,
	IP_CAMERA_CFG_HTTP_PORT,
	IP_CAMERA_CFG_RTSP_PORT,
	IP_CAMERA_CFG_USERNAME,
	IP_CAMERA_CFG_PASSWORD,
	IP_CAMERA_CFG_ONVIF_SUPPORT_FLAG,
	IP_CAMERA_CFG_ONVIF_PORT,
	IP_CAMERA_CFG_RTSP_PROTOCOL,
	IP_CAMERA_CFG_MAC_ADDR,
	MAX_IP_CAMERA_CFG_FIELD

}IP_CAMERA_CFG_FIELD_e;

// Table-50 Netork Device Configuration Enum
typedef enum
{
	NETWORK_DEVICE_CFG_DEVICE_NAME,
	NETWORK_DEVICE_CFG_REGISTER_MODE,
	NETWORK_DEVICE_CFG_REGISTER_MODE_ADDRESS,
	NETWORK_DEVICE_CFG_PORT,
	NETWORK_DEVICE_CFG_USERNAME,
	NETWORK_DEVICE_CFG_PASSWORD,
	NETWORK_DEVICE_CFG_ENABLE,
	NETWORK_DEVICE_CFG_AUTO_LOGIN,
	NETWORK_DEVICE_CFG_LIVE_STREAM_TYPE,
	NETWORK_DEVICE_CFG_PREFER_DEV_CREDENTIAL,
	NETWORK_DEVICE_CFG_FORWARDED_PORT,
	MAX_NETWORK_DEVICE_CFG_FIELD

}NETWORK_DEVICE_CFG_FIELD_e;

//Table-52 snapshot Upload Configuration Enum
typedef enum
{
	SNPSHT_UPLD_ENABLE,
	SNPSHT_UPLD_LOCATION,
	SNPSHT_UPLD_EMAIL_ADDR,
	SNPSHT_UPLD_EMAIL_SUBJECT,
	SNPSHT_UPLD_EMAIL_MESSAGE,
	SNPSHT_UPLD_RATE,
    SNPSHT_UPLD_COPY_TO_CAMERA_START,
    SNPSHT_UPLD_COPY_TO_CAMERA_END = SNPSHT_UPLD_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_SNPSHT_UPLD_CFG_FIELD

}SNPSHT_UPLD_CFG_e;

//Table-53 snapshotSchedule Upload Configuration Enum
typedef enum
{
	SNPSHT_SCHD_RENTIRE_DAY,
	SNPSHT_SCHD_PERIOD0_START_TIME,
	SNPSHT_SCHD_PERIOD0_END_TIME,
	SNPSHT_SCHD_PERIOD1_START_TIME,
	SNPSHT_SCHD_PERIOD1_END_TIME,
	SNPSHT_SCHD_PERIOD2_START_TIME,
	SNPSHT_SCHD_PERIOD2_END_TIME,
	SNPSHT_SCHD_PERIOD3_START_TIME,
	SNPSHT_SCHD_PERIOD3_END_TIME,
	SNPSHT_SCHD_PERIOD4_START_TIME,
	SNPSHT_SCHD_PERIOD4_END_TIME,
	SNPSHT_SCHD_PERIOD5_START_TIME,
	SNPSHT_SCHD_PERIOD5_END_TIME,
	SNPSHT_SCHD_PERIOD_COPY_TO_WEEKDAYS,
    SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_START,
    SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_END = SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_START + CAMERA_MASK_MAX - 1,
	MAX_SNPSHT_SCHD_CFG_FIELD

}SNPSHT_SCHD_UPLD_CFG_e;

typedef enum
{
	ADAPTIVE_REC_STATUS,
	ADAPTIVE_COPY_TO_CAMERA,
	MAX_ADAPTIVE_REC_CFG_FIELD1

}ADAPTIVE_REC_CFG_e1;

typedef enum
{
	ADAPTIVE_RECD_ENTIRE_DAY,
	ADAPTIVE_PERIOD0_START_TIME,
	ADAPTIVE_PERIOD0_END_TIME,
	ADAPTIVE_PERIOD1_START_TIME,
	ADAPTIVE_PERIOD1_END_TIME,
	ADAPTIVE_PERIOD2_START_TIME,
	ADAPTIVE_PERIOD2_END_TIME,
	ADAPTIVE_PERIOD3_START_TIME,
	ADAPTIVE_PERIOD3_END_TIME,
	ADAPTIVE_PERIOD4_START_TIME,
	ADAPTIVE_PERIOD4_END_TIME,
	ADAPTIVE_PERIOD5_START_TIME,
	ADAPTIVE_PERIOD5_END_TIME,
	ADAPTIVE_PERIOD_COPY_TO_CAMERA,
	MAX_ADAPTIVE_REC_CFG_FIELD2

}ADAPTIVE_REC_CFG_e2;

typedef enum
{
	LOGIN_POLICY_MIN_PASS_CHARCTER,
	LOGIN_POLICY_PASS_RESET_STATUS,
	LOGIN_POLICY_PASS_RESET_PERIOD,
	LOGIN_POLICY_LOCK_ACCOUNT_ATTEMPTS,
	LOGIN_POLICY_LOCK_ATTEMPTS,
	LOGIN_POLICY_AUTO_UNLOCK_TIMER,
	MAX_LOGIN_POLICY_CFG_FIELD

}LOGIN_POLICY_CFG_e;

// Table-55 Audio Out Config
typedef enum
{
	AUDIO_OUT_CFG,
	MAX_AUDIO_OUT_CFG_FIELD

}AUDIO_OUT_CFG_FIELD_e;

// Table-56 P2P Config
typedef enum
{
    P2P_ENABLE,
    P2P_RELAY_SERVER_FALLBACK,
    MAX_P2P_CFG_FIELD

}P2P_CFG_FIELD_e;

// Table-58 DHCP Server Config
typedef enum
{
    DHCP_SERVER_CFG_ENABLE = 0,
    DHCP_SERVER_CFG_ETHERNET_PORT,
    DHCP_SERVER_CFG_START_IP_ADDR,
    DHCP_SERVER_CFG_NUMBER_OF_HOSTS,
    DHCP_SERVER_CFG_GATEWAY,
    DHCP_SERVER_CFG_DNS_SERVER_ADDR,
    DHCP_SERVER_CFG_LEASE_HOURS,
    MAX_DHCP_SERVER_CFG_FIELD

}DHCP_SERVER_CFG_FIELD_e;

// Table-59 Firmware Management Config
typedef enum
{
    FIRMWARE_MANAGEMENT_CFG_MODE = 0,
    FIRMWARE_MANAGEMENT_CFG_SCHEDULE,
    FIRMWARE_MANAGEMENT_CFG_FTP_SERVER_TYPE,
    FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_ADDR,
    FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PORT,
    FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_USERNAME,
    FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PASSWORD,
    FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PATH,
    MAX_FIRMWARE_MANAGEMENT_CFG_FIELD

}FIRMWARE_MANAGEMENT_CFG_FIELD_e;

// Table-60 FCM Push Notification Config
typedef enum
{
    FCM_PUSH_NOTIFICATION_CFG_USERNAME = 0,
    FCM_PUSH_NOTIFICATION_CFG_DEV_TOKEN,
    FCM_PUSH_NOTIFICATION_CFG_DEV_MODEL_NAME,
    MAX_FCM_PUSH_NOTIFICATION_CFG_FIELD

}FCM_PUSH_NOTIFICATION_CFG_FIELD_e;

// Table-61 Password Recovery Config
typedef enum
{
    PASSWORD_RECOVERY_CFG_EMAIL_ID = 0,
    PASSWORD_RECOVERY_CFG_SEC_QUE_ID_1,
    PASSWORD_RECOVERY_CFG_SEC_ANS_1,
    PASSWORD_RECOVERY_CFG_SEC_QUE_ID_2,
    PASSWORD_RECOVERY_CFG_SEC_ANS_2,
    PASSWORD_RECOVERY_CFG_SEC_QUE_ID_3,
    PASSWORD_RECOVERY_CFG_SEC_ANS_3,
    MAX_PASSWORD_RECOVERY_CFG_FIELD

}PASSWORD_RECOVERY_CFG_FIELD_e;

// Table-62 Storage Allocation Config
typedef enum
{
    STORAGE_ALLOCATION_VOLUME_MASK_GROUP_START = 0,
    STORAGE_ALLOCATION_VOLUME_MASK_GROUP_END = (STORAGE_ALLOCATION_VOLUME_MASK_GROUP_START + STORAGE_ALLOCATION_GROUP_MAX - 1),
    STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START,
    STORAGE_ALLOCATION_CAMERA_MASK_GROUP_END = (STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START + (STORAGE_ALLOCATION_GROUP_MAX * CAMERA_MASK_MAX) - 1),
    MAX_STORAGE_ALLOCATION_CFG_FIELD,

}STORAGE_ALLOCATION_CFG_FIELD_e;

//#################################################################################################
// @PROTOTYPE
//#################################################################################################
//-------------------------------------------------------------------------------------------------
static void getXYIndx(UINT16 indx, UINT16 maxYIdx, UINT16PTR x, UINT16PTR y);
//-------------------------------------------------------------------------------------------------
static void getXYZIndx(UINT16 indx, UINT16 maxYIdx, UINT16 maxZIdx, UINT32PTR x, UINT16PTR y, UINT16PTR z);
//-------------------------------------------------------------------------------------------------
static BOOL fillBitField(BOOL *array, UINT8 maxIdx, UINT64PTR bitField);
//-------------------------------------------------------------------------------------------------
static BOOL fillArrayFrmBitField(BOOL *array, UINT8 maxIdx, UINT64 bitField);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getGeneralCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr,  const UINT32 respStrLen);
static NET_CMD_STATUS_e setGeneralCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defGeneralCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getDateTimeCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setDateTimeCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defDateTimeCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getDstCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setDstCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defDstCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getLan1Cfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setLan1Cfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defLan1Cfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getLan2Cfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setLan2Cfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defLan2Cfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getIPFilterEnableCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setIPFilterEnableCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defIPFilterEnableCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getIPFilterCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setIPFilterCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defIPFilterCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getDdnsCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setDdnsCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defDdnsCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSmtpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSmtpCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defSmtpCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getFtpUploadCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setFtpUploadCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defFtpUploadCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getTcpNotifyCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setTcpNotifyCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defTcpNotifyCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getFileAccessCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setFileAccessCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defFileAccessCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getHddCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setHddCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defHddCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getMatrixDnsServerCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setMatrixDnsServerCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defMatrixDnsServerCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getUserAccountCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setUserAccountCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defUserAccountCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getCameraCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setCameraCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defCameraCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getStreamCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setStreamCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defStreamCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getAlarmRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setAlarmRecordCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defAlarmRecordCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getPresetPositionCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setPresetPositionCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defPresetPositionCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getRecordingScheduleCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setRecordingScheduleCfg1(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultRecordingScheduleCfg1(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getRecordingScheduleCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setRecordingScheduleCfg2(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultRecordingScheduleCfg2(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getPresetTourCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setPresetTourCfg1(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultPresetTourCfg1(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getPresetTourCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setPresetTourCfg2(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultPresetTourCfg2(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getPresetTourSchedCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setPresetTourSchedCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultPresetTourSchedCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSensorCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSensorCnfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSensorCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSystemAlmCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSysAlmCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSysAlmCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getImgUpldCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setImgUpldCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultImgUpldCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getStorageConfig(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setStorageConfig(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultStorageConfig(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSchedBackUpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSchedBackUpCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSchedBackUpCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getManBackUpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setManBackUpCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultManBackUpCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static UINT16 getEvtActfield1(UINT16 fromField, UINT16 toField, BOOL action, ACTION_PARAMETERS_t *actionParam, UINT16PTR actionBits,CHARPTR respStringPtr, CAMERA_BIT_MASK_t *copyToCam, const UINT32 respStrLen);
static BOOL setEvtActField1(UINT16 fieldId, BOOL *action,ACTION_PARAMETERS_t *actionParam, UINT16PTR actionBits, CHARPTR *reqStr, CAMERA_BIT_MASK_t *copyToCam);
static UINT16 getEvtActfield2(UINT16 fromField, UINT16 toField, WEEKLY_ACTION_SCHEDULE_t *weeklySchedule, CHARPTR respStringPtr, const UINT32 respStrLen);
static BOOL setEvtActField2(UINT16 fieldId, WEEKLY_ACTION_SCHEDULE_t *weeklySchedule, CHARPTR *reqStr);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getCameraEACfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setCameraEACfg1(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultCameraEACfg1(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getCameraEACfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setCameraEACfg2(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultCameraEACfg2(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSensorEaParamCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSensorEaParamCfg1(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSensorEaParamCfg1(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSensorEaParamCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSensorEaParamCfg2(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSensorEaParamCfg2(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSystemEaParamCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSystemEaParamCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSystemEaParamCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getCosecRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setCosecRecordCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultCosecRecordCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getCameraAlmCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setCameraAlmCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultCameraAlmCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getDfltRoutingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setDfltRoutingCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultDfltRoutingCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getStaticRoutingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setStaticRoutingCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultStaticRoutingCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getBroadBandCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setBroadBandCfg1(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultBroadBandCfg1(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getBroadBandCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setBroadBandCfg2(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultBroadBandCfg2(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSmsCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSmsCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultSmsCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getManualRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setManualRecordCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultManualRecordCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getNwDriveCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setNwDriveCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defaultNwDriveCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getIpCameraCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setIpCameraCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defIpCameraCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getNetworkDeviceCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setNetworkDeviceCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defNetworkDeviceCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSnapshotCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSnapshotCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defSnapshotCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getSnapshotSchdCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setSnapshotSchdCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defSnapshotSchdCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getLoginPolicyCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setLoginPolicyCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defLoginPolicyCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getAudioOutCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setAudioOutCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defAudioOutCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getP2PCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setP2PCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defP2PCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getImgSettingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setImgSettingCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defImgSettingCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getDhcpServerCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setDhcpServerCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defDhcpServerCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getFirmwareManagementCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setFirmwareManagementCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defFirmwareManagementCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getFcmPushNotificationCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setFcmPushNotificationCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defFcmPushNotificationCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getPasswordRecoveryCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setPasswordRecoveryCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defPasswordRecoveryCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
static NET_CMD_STATUS_e getStorageAllocationCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen);
static NET_CMD_STATUS_e setStorageAllocationCfg(CHARPTR *reqStr);
static NET_CMD_STATUS_e defStorageAllocationCfg(UINT16 fromIndex, UINT16 toIndex);
//-------------------------------------------------------------------------------------------------
//#################################################################################################
// @STATIC VARIABLES
//#################################################################################################
static const UINT16 maxFieldPerTable[MAX_TBL_CFG] =
{
	MAX_GEN_CFG_FIELD,
	MAX_DATE_TIME_CFG_FIELD,
	MAX_DST_CFG_FIELD,
    0,
	MAX_LAN_1_CFG_FIELD,
	MAX_LAN_2_CFG_FIELD,
	MAX_IP_FILTER_ENABLE_CFG_FIELD,
	MAX_IP_FILTER_CFG_FIELD,
	MAX_DDNS_CFG_FIELD,
	MAX_SMTP_CFG_FIELD,
	MAX_FTP_UPLOAD_CFG_FIELD,
	MAX_TCP_NOTIFY_CFG_FIELD,
	MAX_FILE_ACCESS_CFG_FIELD,
	MAX_HDD_CFG_FIELD,
	MAX_MATRIX_DNS_SERVER_CFG_FIELD,
	MAX_USER_ACCOUNT_CFG_FIELD,
	MAX_CAMERA_CFG_FIELD,
	MAX_STREAM_CFG_FIELD,
	MAX_SCHED_RECD_CFG_FIELD1,
	MAX_SCHED_RECD_CFG_FIELD2,
	MAX_ALARM_RECORD_CFG_FIELD,
	MAX_PRESET_POSITION_CFG_FIELD,
	MAX_PRESET_TOUR_CONFIG_FIELD1,
	MAX_PRESET_TOUR_CONFIG_FIELD2,
	MAX_PRESET_TOUR_SCHED_CONFIG_FIELD,
	MAX_SENSOR_CONFIG_FIELD,
	MAX_SYS_ALM_CFG_FIELD,
	MAX_IMG_UPLD_CFG_FIELD,
	MAX_STORAGE_CFG_FIELD,
	MAX_SCHEDULE_BACKUP_CFG_FIELD,
	MAX_MANUAL_BACKUP_CFG_FIELD,
	MAX_CAMERA_EVENT_CFG_FIELD1,
	MAX_CAMERA_EVENT_CFG_FIELD2,
	MAX_CAMERA_EVENT_CFG_FIELD1,
	MAX_CAMERA_EVENT_CFG_FIELD2,
	MAX_CAMERA_EVENT_CFG_FIELD1,
	MAX_COSEC_REC_FIELD,
	MAX_CAM_ALM_CFG_FIELD,
	MAX_STAT_ROUTE_FIELD1,
	MAX_STAT_ROUTE_FIELD2,
	MAX_BRD_BND_CFG_FIELD1,
	MAX_BRD_BND_CFG_FIELD2,
	MAX_SMS_CFG_FIELD,
	MAX_MAN_RECORD_CFG_FIELD,
	MAX_NW_DRIVE_CFG_FIELD,
	MAX_IP_CAMERA_CFG_FIELD,
    0,
    0,
    0,
    0,
	MAX_NETWORK_DEVICE_CFG_FIELD,
	MAX_SNPSHT_UPLD_CFG_FIELD,
	MAX_SNPSHT_SCHD_CFG_FIELD,
	MAX_LOGIN_POLICY_CFG_FIELD,
    MAX_AUDIO_OUT_CFG_FIELD,
    MAX_P2P_CFG_FIELD,
    MAX_IMG_SETTING_CFG_FIELD,
    MAX_DHCP_SERVER_CFG_FIELD,
    MAX_FIRMWARE_MANAGEMENT_CFG_FIELD,
    MAX_FCM_PUSH_NOTIFICATION_CFG_FIELD,
    MAX_PASSWORD_RECOVERY_CFG_FIELD,
    MAX_STORAGE_ALLOCATION_CFG_FIELD,
};

static UINT16 maxIndexPerTable[MAX_TBL_CFG] =
{
	MAX_GENERAL_INDEX,
	MAX_DATE_TIME_INDEX,
	MAX_DST_INDEX,
    0,
	MAX_LAN1_INDEX,
	MAX_LAN2_INDEX,
	MAX_IP_FLTR_APPLY_INDEX,
	MAX_IP_FLTR_INDEX,
	MAX_DDNS_INDEX,
	MAX_SMTP_INDEX,
	MAX_FTP_INDEX,
	MAX_TCP_NOTIFY_INDEX,
	MAX_FILE_ACCESS_INDEX,
	MAX_HDD_INDEX,
	MAX_MATRIX_DNS_SERVER_INDEX,
	MAX_USER_ACCOUNT_INDEX,
	MAX_CAMERA_INDEX,
	MAX_STREAM_INDEX,
	MAX_ENBL_SCHEDL_RECORD_INDEX,
	MAX_SCHEDL_RECORD_INDEX,
	MAX_ALARM_RECORD_INDEX,
	MAX_PRESET_POSITION_INDEX,
	MAX_MAN_PRESET_TOUR_INDEX,
	MAX_AUTO_PRESET_TOUR_INDEX,
	MAX_PRESET_TOUR_SCHEDL_INDEX,
	MAX_SYSTEM_SENSOR_INDEX,
	MAX_SYSTEM_ALARM_INDEX,
	MAX_UPLOAD_IMAGE_INDEX,
	MAX_STORAGE_INDEX,
	MAX_SCHEDL_BACKUP_INDEX,
	MAX_MAN_BACKUP_INDEX,
	MAX_CAMERA_E_A_INDEX,
	MAX_CAMERA_E_A_SCHEDL_INDEX,
	MAX_SENSOR_E_A_INDEX,
	MAX_SENSOR_E_A_SCHEDL_INDEX,
	MAX_SYSTEM_E_A_INDEX,
	MAX_COSEC_REC_CFG_INDEX,
	MAX_CAMERA_ALARM_INDEX,
	MAX_DEFAULT_ROUTING_INDEX,
	MAX_STATIC_ROUTING_INDEX,
	MAX_BROAD_BAND_PRO_INDEX,
	MAX_BROAD_BAND_INDEX,
	MAX_SMS_INDEX,
	MAX_MANUAL_RECORD_INDEX,
	MAX_NETWORK_DRIVE_INDEX,
	MAX_IP_CAMERA_INDEX,
    0,
    0,
    0,
    0,
	MAX_NETWORK_DEVICES,
	MAX_SCHEDL_INDEX,
	MAX_SCHEDL_SCHD_INDEX,
	MAX_LOGIN_POLICY_INDEX,
    MAX_AUDIO_OUT_INDEX,
    MAX_P2P_CONFIG_INDEX,
    MAX_IMG_SETTING_INDEX,
    MAX_DHCP_SERVER_INDEX,
    MAX_FIRMWARE_MANAGEMENT_INDEX,
    MAX_FCM_PUSH_NOTIFICATION_INDEX,
    MAX_PASSWORD_RECOVERY_INDEX,
    MAX_STORAGE_ALLOCATION_INDEX,
};

static NET_CMD_STATUS_e (*getCfgFuncPtr[MAX_TBL_CFG])(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStr, const UINT32 respStrLen) =
{
	getGeneralCfg,					// tableId 01
	getDateTimeCfg,					// tableId 02
	getDstCfg,						// tableId 03
    NULL,                           // tableId 04
	getLan1Cfg,						// tableId 05
	getLan2Cfg,						// tableId 06
	getIPFilterEnableCfg,			// tableId 07
	getIPFilterCfg,					// tableId 08
	getDdnsCfg,						// tableId 09
	getSmtpCfg,						// tableId 10
	getFtpUploadCfg,				// tableId 11
	getTcpNotifyCfg,				// tableId 12
	getFileAccessCfg,				// tableId 13
	getHddCfg,						// tableId 14
	getMatrixDnsServerCfg,			// tableId 15
	getUserAccountCfg,				// tableId 16
	getCameraCfg,					// tableId 17
	getStreamCfg,					// tableId 18
	getRecordingScheduleCfg1,		// tableId 19
	getRecordingScheduleCfg2,		// tableId 20
	getAlarmRecordCfg,				// tableId 21
	getPresetPositionCfg,			// tableId 22
	getPresetTourCfg1,				// tableId 23
	getPresetTourCfg2,				// tableId 24
	getPresetTourSchedCfg,			// tableId 25
	getSensorCfg,					// tableId 26
	getSystemAlmCfg,				// tableId 27
	getImgUpldCfg,					// tableId 28
	getStorageConfig,				// tableId 29
	getSchedBackUpCfg,				// tableId 30
	getManBackUpCfg,				// tableId 31
	getCameraEACfg1,				// tableId 32
	getCameraEACfg2,				// tableId 33
	getSensorEaParamCfg1,			// tableId 34
	getSensorEaParamCfg2,			// tableId 35
	getSystemEaParamCfg,			// tableId 36
	getCosecRecordCfg,				// tableId 37
	getCameraAlmCfg,				// tableId 38
	getDfltRoutingCfg,				// tableID 39
	getStaticRoutingCfg,			// tableID 40
	getBroadBandCfg1,				// tableID 41
	getBroadBandCfg2,				// tableID 42
	getSmsCfg,						// tableID 43
	getManualRecordCfg,				// tableID 44
	getNwDriveCfg,					// tableID 45
	getIpCameraCfg,					// tableID 46
    NULL,                           // tableID 47
    NULL,                           // tableID 48
    NULL,                           // tableID 49
    NULL,                           // tableID 50
	getNetworkDeviceCfg,			// tableID 51
	getSnapshotCfg,					// tableId 52
	getSnapshotSchdCfg,				// tableId 53
    getLoginPolicyCfg,				// tableId 54
    getAudioOutCfg,					// tableId 55
    getP2PCfg,                      // tableId 56
    getImgSettingCfg,               // tableId 57
    getDhcpServerCfg,               // tableId 58
    getFirmwareManagementCfg,       // tableId 59
    getFcmPushNotificationCfg,      // tableId 60
    getPasswordRecoveryCfg,         // tableId 61
    getStorageAllocationCfg,        // tableId 62
};

static NET_CMD_STATUS_e (*defCfgFuncPtr[MAX_TBL_CFG])(UINT16 fromIndex, UINT16 toIndex) =
{
	defGeneralCfg,					// tableId 01
	defDateTimeCfg,					// tableId 02
	defDstCfg,						// tableId 03
    NULL,                           // tableId 04
	defLan1Cfg,						// tableId 05
	defLan2Cfg,						// tableId 06
	defIPFilterEnableCfg,			// tableId 07
	defIPFilterCfg,					// tableId 08
	defDdnsCfg,						// tableId 09
	defSmtpCfg,						// tableId 10
	defFtpUploadCfg,				// tableId 11
	defTcpNotifyCfg,				// tableId 12
	defFileAccessCfg,				// tableId 13
	defHddCfg,						// tableId 14
	defMatrixDnsServerCfg,			// tableId 15
	defUserAccountCfg,				// tableId 16
	defCameraCfg,					// tableId 17
	defStreamCfg,					// tableId 18
	defaultRecordingScheduleCfg1,	// tableId 19
	defaultRecordingScheduleCfg2,	// tableId 20
	defAlarmRecordCfg,				// tableId 21
	defPresetPositionCfg,			// tableId 22
	defaultPresetTourCfg1,			// tableId 23
	defaultPresetTourCfg2,			// tableId 24
	defaultPresetTourSchedCfg,		// tableId 25
	defaultSensorCfg,				// tableId 26
	defaultSysAlmCfg,				// tableId 27
	defaultImgUpldCfg,				// tableId 28
	defaultStorageConfig,			// tableId 29
	defaultSchedBackUpCfg,			// tableId 30
	defaultManBackUpCfg,			// tableId 31
	defaultCameraEACfg1,			// tableId 32
	defaultCameraEACfg2,			// tableId 33
	defaultSensorEaParamCfg1,		// tableId 34
	defaultSensorEaParamCfg2,		// tableId 35
	defaultSystemEaParamCfg,		// tableId 36
	defaultCosecRecordCfg,			// tableId 37
	defaultCameraAlmCfg,			// tableId 38
	defaultDfltRoutingCfg,			// tableID 39
	defaultStaticRoutingCfg,		// tableID 40
	defaultBroadBandCfg1,			// tableID 41
	defaultBroadBandCfg2,			// tableID 42
	defaultSmsCfg,					// tableID 43
	defaultManualRecordCfg,			// tableID 44
	defaultNwDriveCfg,				// tableID 45
	defIpCameraCfg,					// tableID 46
    NULL,                           // tableID 47
    NULL,                           // tableID 48
    NULL,                           // tableID 49
    NULL,                           // tableID 50
	defNetworkDeviceCfg,			// tableID 51
	defSnapshotCfg,					// tableId 52
	defSnapshotSchdCfg,				// tableId 53
    defLoginPolicyCfg,				// tableId 54
    defAudioOutCfg,					// tableId 55
    defP2PCfg,                      // tableId 56
    defImgSettingCfg,               // tableId 57
    defDhcpServerCfg,               // tableId 58
    defFirmwareManagementCfg,       // tableId 59
    defFcmPushNotificationCfg,      // tableId 60
    defPasswordRecoveryCfg,         // tableId 61
    defStorageAllocationCfg,        // tableId 62
};

static NET_CMD_STATUS_e (*setCfgFuncPtr[MAX_TBL_CFG])(CHARPTR *reqStr) =
{
	setGeneralCfg,					// tableId 01
	setDateTimeCfg,					// tableId 02
	setDstCfg,						// tableId 03
    NULL,                           // tableId 04
	setLan1Cfg,						// tableId 05
	setLan2Cfg,						// tableId 06
	setIPFilterEnableCfg,			// tableId 07
	setIPFilterCfg,					// tableId 08
	setDdnsCfg,						// tableId 09
	setSmtpCfg,						// tableId 10
	setFtpUploadCfg,				// tableId 11
	setTcpNotifyCfg,				// tableId 12
	setFileAccessCfg,				// tableId 13
	setHddCfg,						// tableId 14
	setMatrixDnsServerCfg,			// tableId 15
	setUserAccountCfg,				// tableId 16
	setCameraCfg,					// tableId 17
	setStreamCfg,					// tableId 18
	setRecordingScheduleCfg1,		// tableId 19
	setRecordingScheduleCfg2,		// tableId 20
	setAlarmRecordCfg,				// tableId 21
	setPresetPositionCfg,			// tableId 22
	setPresetTourCfg1,				// tableId 23
	setPresetTourCfg2,				// tableId 24
	setPresetTourSchedCfg,			// tableId 25
	setSensorCnfg,					// tableId 26
	setSysAlmCfg,					// tableId 27
	setImgUpldCfg,					// tableId 28
	setStorageConfig,				// tableId 29
	setSchedBackUpCfg,				// tableId 30
	setManBackUpCfg,				// tableId 31
	setCameraEACfg1,				// tableId 32
	setCameraEACfg2,				// tableId 33
	setSensorEaParamCfg1,			// tableId 34
	setSensorEaParamCfg2,			// tableId 35
	setSystemEaParamCfg,			// tableId 36
	setCosecRecordCfg,				// tableId 37
	setCameraAlmCfg,				// tableId 38
	setDfltRoutingCfg,				// tableID 39
	setStaticRoutingCfg,			// tableID 40
	setBroadBandCfg1,				// tableID 41
	setBroadBandCfg2,				// tableID 42
	setSmsCfg,						// tableID 43
	setManualRecordCfg,				// tableID 44
	setNwDriveCfg,					// tableID 45
	setIpCameraCfg,					// tableID 46
    NULL,                           // tableID 47
    NULL,                           // tableID 48
    NULL,                           // tableID 49
    NULL,                           // tableID 50
	setNetworkDeviceCfg,			// tableID 51
	setSnapshotCfg,					// tableId 52
	setSnapshotSchdCfg,				// tableId 53
    setLoginPolicyCfg,				// tableId 54
    setAudioOutCfg,					// tableId 55
    setP2PCfg,                      // tableId 56
    setImgSettingCfg,               // tableId 57
    setDhcpServerCfg,               // tableId 58
    setFirmwareManagementCfg,       // tableId 59
    setFcmPushNotificationCfg,      // tableId 60
    setPasswordRecoveryCfg,         // tableId 61
    setStorageAllocationCfg,        // tableId 62
};

//#################################################################################################
// @GLOBAL VARIABLES
//#################################################################################################
// This pointer is constant and used in evry require Table Index comparision
static const UINT16 *const totalIndexPerEveryTable = (UINT16*)maxIndexPerTable;

//#################################################################################################
// @DEFINATION
//#################################################################################################
//-------------------------------------------------------------------------------------------------
/**
 * @brief   These functions first time initialize value of configuration(every table)
 * @note    Table index value should be modify only Init time(only one time), maxIndexPerTable variable
 *          not modify in any other place. Runtime Detection and totalIndexPerEveryTable pointer will
 *          used in everyplace instead of maxIndexPerTable
 */
void InitNetworkConfig(void)
{
	UINT16 tableNo;

	for(tableNo = 0; tableNo < MAX_TBL_CFG; tableNo++)
	{
		switch(tableNo)
		{
            case TBL_CAMERA_CFG:                    // tableId 17
            case TBL_STREAM_CFG:                    // tableId 18
            case TBL_ENABLE_SCHEDULE_RECORD_CFG:    // tableId 19
            case TBL_ALARM_RECORD_CFG:              // tableId 21
            case TBL_MANUAL_PRESET_TOUR_CFG:        // tableId 23
            case TBL_UPLOAD_IMAGE_CFG:              // tableId 28
            case TBL_COSEC_RECORD_CFG:				// tableId 37
            case TBL_MANUAL_RECORD_CFG:				// tableId 44
            case TBL_IP_CAMERA_CFG:					// tableId 46
            case TBL_SNAPSHOT_CFG:					// tableId 52
            case TBL_SNAPSHOT_SCHEDULE_CFG:			// tableId 53
            case TBL_IMG_SETTING_CFG:               // tableId 57
                maxIndexPerTable[tableNo] = (UINT16)getMaxCameraForCurrentVariant();
                break;

            case TBL_SCHEDULE_RECORD_CFG:           // tableId 20
            case TBL_PRESET_TOUR_CFG:               // tableId 25
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_WEEK_DAYS);
                break;

            case TBL_PRESET_POSITION_CFG:           // tableId 22
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_PRESET_POSITION);
                break;

            case TBL_AUTO_PRESET_TOUR_CFG:          // tableId 24
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_TOUR_NUMBER);
                break;

            case TBL_CAMERA_EVENT_ACTION_PARAM_CFG: // tableId 32
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_CAMERA_EVENT);
                break;

            case TBL_CAMERA_EVENT_SCHEDUL_CFG:      // tableId 33
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_CAMERA_EVENT * MAX_WEEK_DAYS);
                break;

            case TBL_CAMERA_ALARM_CFG:				// tableId 38
                maxIndexPerTable[tableNo] = ((UINT16)getMaxCameraForCurrentVariant() * MAX_CAMERA_ALARM);
                break;

            default:
                break;
		}
	}
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   decompose x,y index from given indx
 * @param   indx
 * @param   maxYIdx
 * @param   x
 * @param   y
 */
static void getXYIndx(UINT16 indx, UINT16 maxYIdx, UINT16PTR x, UINT16PTR y)
{
	*x = indx / maxYIdx;
	*y = indx % maxYIdx;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   decompose x,y,z index from given indx
 * @param   indx
 * @param   maxYIdx
 * @param   maxZIdx
 * @param   x
 * @param   y
 * @param   z
 */
static void getXYZIndx(UINT16 indx, UINT16 maxYIdx, UINT16 maxZIdx, UINT32PTR x, UINT16PTR y, UINT16PTR z)
{
	UINT16 remainder;

	*x = indx / (maxYIdx * maxZIdx);
	remainder = indx % (maxYIdx * maxZIdx);
	*y = remainder / maxZIdx;
	*z = remainder % maxZIdx;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   from array it will set the bitfield.
 * @param   array
 * @param   maxIdx
 * @param   bitField
 * @return  SUCCESS/FAIL
 */
BOOL fillBitField(BOOL *array, UINT8 maxIdx, UINT64PTR bitField)
{
	UINT8 bitIdx;

    if ((array == NULL) || (bitField == NULL))
	{
        return FAIL;
	}

    *bitField = 0;
    for(bitIdx = 1; bitIdx <= maxIdx; bitIdx++)
    {
        *bitField = (array[maxIdx - bitIdx] + (*bitField << 1));
    }

    return SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   fill the array field according to bitfield
 * @param   array
 * @param   maxIdx
 * @param   bitField
 * @return  SUCCESS/FAIL
 */
BOOL fillArrayFrmBitField(BOOL *array, UINT8 maxIdx, UINT64 bitField)
{
	UINT8 bitIdx;

	if(array == NULL)
	{
        return FAIL;
	}

    for(bitIdx = 0 ; bitIdx < maxIdx; bitIdx++)
    {
        array[bitIdx] = bitField & 1;
        bitField = bitField >> 1;
    }

    return SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   This API parses the request string for TABLE ID, INDEX ID, FIELD ID. It then fills the
 *          destination buffer with the value of requested FIELDS.
 * @param   source
 * @param   connFd
 * @param   callbackType
 * @return  SUCCESS/FAIL
 */
BOOL ProcessGetConfig(CHARPTR source, INT32 connFd, CLIENT_CB_TYPE_e callbackType)
{
	UINT64 				getCfgParam[MAX_GET_CMD_PARAM];
	UINT32				outLen;
	NET_CMD_STATUS_e	respStatus = CMD_SUCCESS;
    UINT32 				tableId = 0;
    CHAR                replyMsg[MAX_REPLY_SZ];

	// compose get configuration reply header SOM HEADER FSP
    outLen = snprintf(replyMsg, MAX_REPLY_SZ, "%c%s%c", SOM, headerReq[RPL_CFG], FSP);
    if(outLen > MAX_REPLY_SZ - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = MAX_REPLY_SZ - 2;
    }

	// check for the validation of input/output parameter
	if (source != NULL)
	{
		// by default compose SUCCESS response
        outLen += snprintf(replyMsg + outLen, MAX_REPLY_SZ - outLen, "%d%c", CMD_SUCCESS, FSP);
        if(outLen > MAX_REPLY_SZ)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = MAX_REPLY_SZ;
        }

		// parse the source string till EOM is not reached
		while(*source != EOM)
		{
			// check for the presence of SOT
			if(*source != SOT)
			{
				respStatus = CMD_INVALID_SYNTAX;
				break;
			}

            // start parsing source string for individual fields like tableId, from-to index, from-to field
            source++;
            if (ParseStringGetVal(&source, getCfgParam, MAX_GET_CMD_PARAM, FSP) == FAIL)
            {
                respStatus = CMD_INVALID_SYNTAX;
                break;
            }

            // check for the presence of EOT
            if (*source != EOT)
            {
                respStatus = CMD_INVALID_SYNTAX;
                break;
            }

            // validate the converted tableId, indexId and fieldId and their range if any of validation fails, send appropriate error response
            tableId = CLIENT_TO_OUR_INDEX(getCfgParam[GET_TABLE_ID]);
            if ((tableId >= MAX_TBL_CFG) || (getCfgParam[GET_TABLE_ID] == 0))
            {
                respStatus = CMD_INVALID_TABLE_ID;
                EPRINT(NETWORK_MANAGER, "invld table id: [tableId=%d]", tableId);
                break;
            }

            if ((getCfgParam[GET_FROM_INDEX_ID] == 0) || (getCfgParam[GET_TO_INDEX_ID] == 0)
                    || (getCfgParam[GET_FROM_INDEX_ID] > (UINT64)totalIndexPerEveryTable[tableId])
                    || (getCfgParam[GET_TO_INDEX_ID] > (UINT64)totalIndexPerEveryTable[tableId])
                    || (getCfgParam[GET_FROM_INDEX_ID] > getCfgParam[GET_TO_INDEX_ID]))
            {
                respStatus = CMD_INVALID_INDEX_ID;
                EPRINT(NETWORK_MANAGER, "invld index id: [tableId=%d], [fromIndex=%lld], [toIndex=%lld]",
                       tableId, CLIENT_TO_OUR_INDEX(getCfgParam[GET_FROM_INDEX_ID]), CLIENT_TO_OUR_INDEX(getCfgParam[GET_TO_INDEX_ID]));
                break;
            }

            if ((getCfgParam[GET_FROM_FIELD_ID] == 0) || (getCfgParam[GET_TO_FIELD_ID] == 0)
                    || (getCfgParam[GET_FROM_FIELD_ID] > maxFieldPerTable[tableId])
                    || (getCfgParam[GET_TO_FIELD_ID] > maxFieldPerTable[tableId])
                    || (getCfgParam[GET_FROM_FIELD_ID] > getCfgParam[GET_TO_FIELD_ID]))
            {
                respStatus = CMD_INVALID_FIELD_ID;
                EPRINT(NETWORK_MANAGER, "invld field id: [tableId=%d], [fromField=%lld], [toField=%lld]",
                       tableId, CLIENT_TO_OUR_INDEX(getCfgParam[GET_FROM_FIELD_ID]), CLIENT_TO_OUR_INDEX(getCfgParam[GET_TO_FIELD_ID]));
                break;
            }

            // Adjust index
            getCfgParam[GET_TABLE_ID] = tableId;
            getCfgParam[GET_FROM_INDEX_ID] = CLIENT_TO_OUR_INDEX(getCfgParam[GET_FROM_INDEX_ID]);
            getCfgParam[GET_TO_INDEX_ID] = CLIENT_TO_OUR_INDEX(getCfgParam[GET_TO_INDEX_ID]);
            getCfgParam[GET_FROM_FIELD_ID] = CLIENT_TO_OUR_INDEX(getCfgParam[GET_FROM_FIELD_ID]);
            getCfgParam[GET_TO_FIELD_ID] = CLIENT_TO_OUR_INDEX(getCfgParam[GET_TO_FIELD_ID]);

            DPRINT(NETWORK_MANAGER, "[table=%lld], [index=%lld -> %lld], [field=%lld -> %lld]",
                   getCfgParam[GET_TABLE_ID], getCfgParam[GET_FROM_INDEX_ID],
                   getCfgParam[GET_TO_INDEX_ID], getCfgParam[GET_FROM_FIELD_ID], getCfgParam[GET_TO_FIELD_ID]);

            // append SOT and tableId at beginning of single table response
            outLen += snprintf(replyMsg + outLen, MAX_REPLY_SZ - outLen, "%c%d%c", SOT, (UINT32)(getCfgParam[GET_TABLE_ID] + 1), FSP);
            if(outLen > MAX_REPLY_SZ)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = MAX_REPLY_SZ;
                break;
            }

            if (getCfgFuncPtr[getCfgParam[GET_TABLE_ID]] == NULL)
            {
                respStatus = CMD_PROCESS_ERROR;
                break;
            }

            respStatus = getCfgFuncPtr[getCfgParam[GET_TABLE_ID]](getCfgParam[GET_FROM_INDEX_ID], getCfgParam[GET_TO_INDEX_ID],
                                                                  getCfgParam[GET_FROM_FIELD_ID], getCfgParam[GET_TO_FIELD_ID],
                                                                  (replyMsg + outLen), MAX_REPLY_SZ - outLen);
            if (respStatus != CMD_SUCCESS)
            {
                // Error occurred in constructing response
                break;
            }

            outLen = strlen(replyMsg);
            if(outLen > MAX_REPLY_SZ - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = MAX_REPLY_SZ - 2;
                break;
            }

            // append EOT at the end of single table response
            outLen += snprintf(replyMsg + outLen, MAX_REPLY_SZ - outLen, "%c", EOT);

            // increment source pointer to next table request, if any, or EOM
            source++;
		}
	}

	if (respStatus != CMD_SUCCESS)
	{
        outLen = snprintf(replyMsg, MAX_REPLY_SZ, "%c%s%c%d%c", SOM, headerReq[RPL_CFG], FSP, respStatus, FSP);
	}

    if(outLen > MAX_REPLY_SZ - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = MAX_REPLY_SZ - 2;
    }

	// append EOM at end the string, and send it to client
    outLen += snprintf(replyMsg + outLen, MAX_REPLY_SZ - outLen, "%c", EOM);

    if(outLen > MAX_REPLY_SZ)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = MAX_REPLY_SZ;
    }

	// send reply to client
    sendCmdCb[callbackType](connFd, (UINT8PTR)replyMsg, outLen, MESSAGE_REPLY_TIMEOUT);
    return SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief   This API parses the TABLE ID, INDEX ID and FIELD ID. It then updates the configuration
 *          field value with the new value received.
 * @param   source
 * @param   connFd
 * @param   advncDetail
 * @param   callbackType
 * @return  SUCCESS/FAIL
 */
BOOL ProcessSetConfig(CHARPTR source, INT32 connFd, CHARPTR advncDetail, CLIENT_CB_TYPE_e callbackType)
{
    CHAR                eventDetail[MAX_EVENT_DETAIL_SIZE];
    UINT64              tableId = 0;
    UINT32              outLen;
    NET_CMD_STATUS_e    respStatus = CMD_SUCCESS;
    CHAR                replyMsg[MAX_REPLY_SZ];

	// validate for invalid input/output parameters
	if (source != NULL)
	{
		// loop until end of message
		while (*source != EOM)
		{
			// check for presence of SOT
			if (*source != SOT)
			{
				// if start of table not found, send syntax error response
				respStatus = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "invld syntax in set config: [tableId=%lld]", tableId);
                break;
			}

            // parse tableId string from set request string
            source++;
            if (ParseStringGetVal(&source, &tableId, 1, FSP) != SUCCESS)
            {
                // if tableId string not found, send syntax error response
                respStatus = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "syntax error in config: [tableId=%lld]", tableId);
                break;
            }

            if ((tableId == 0) || (tableId > MAX_TBL_CFG))
            {
                // if tableId exceeds maximum limit, send invalid tableId response
                respStatus = CMD_INVALID_TABLE_ID;
                EPRINT(NETWORK_MANAGER, "table id exceeds maximum limit: [tableId=%lld]", tableId);
                break;
            }

            // Decrement for adjusting index
            tableId = CLIENT_TO_OUR_INDEX(tableId);
            if (setCfgFuncPtr[tableId] == NULL)
            {
                respStatus = CMD_PROCESS_ERROR;
                EPRINT(NETWORK_MANAGER, "invld table id: [tableId=%lld]", tableId);
                break;
            }

            DPRINT(NETWORK_MANAGER, "[tableId=%lld]", tableId);
            respStatus = setCfgFuncPtr[tableId](&source);
            if (respStatus != CMD_SUCCESS)
            {
                EPRINT(NETWORK_MANAGER, "fail to set config: [tableId=%lld], [status=%d]", tableId, respStatus);
                break;
            }

            GET_EVENT_CONFIG_DETAIL(eventDetail, MAX_EVENT_DETAIL_SIZE, tableId);
            WriteEvent(LOG_USER_EVENT, LOG_CONFIG_CHANGE, eventDetail, advncDetail, EVENT_CHANGE);
		}
	}

	// compose get configuration reply header SOM HEADER FSP
    outLen = snprintf(replyMsg, MAX_REPLY_SZ, "%c%s%c%d%c%c", SOM, headerReq[RPL_CFG], FSP, respStatus, FSP, EOM);
    sendCmdCb[callbackType](connFd, (UINT8PTR)replyMsg, outLen, MESSAGE_REPLY_TIMEOUT);
    return SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/**
 * @brief This API parses the TABLE ID and INDEX ID. It then defaults
          the configuration.
 * @param source
 * @param connFd
 * @param advncDetail
 * @param callbackType
 * @return
 */
BOOL ProcessDefConfig(CHARPTR source, INT32 connFd, CHARPTR advncDetail, CLIENT_CB_TYPE_e callbackType)
{
	UINT64 				defCfgParam[MAX_DEF_CMD_PARAM];
	UINT32				outLen;
	NET_CMD_STATUS_e	respStatus = CMD_SUCCESS;
	CHAR				eventDetail[MAX_EVENT_DETAIL_SIZE];
	UINT32 				totalIndexId = 0;
    CHAR                replyMsg[MAX_REPLY_SZ];

	// check for the validation of input/output parameter
	if (source != NULL)
	{
		// parse the source string till EOM is not reached
		while (*source != EOM)
		{
			// check for the presence of SOT
			if (*source != SOT)
			{
				respStatus = CMD_INVALID_SYNTAX;
                break;
			}

            // point the source string pointer at tableId
            source++;

            // start parsing source string for individual fields like tableId, from-to index, from-to field
            if (ParseStringGetVal(&source, defCfgParam, MAX_DEF_CMD_PARAM, FSP) == FAIL)
            {
                respStatus = CMD_INVALID_SYNTAX;
                break;
            }

            // check for the presence of EOT
            if (*source != EOT)
            {
                respStatus = CMD_INVALID_SYNTAX;
                break;
            }

            // validate the converted tableId, indexId and fieldId and their range if any of validation fails, send appropriate error response
            totalIndexId = CLIENT_TO_OUR_INDEX(defCfgParam[GET_TABLE_ID]);
            if((totalIndexId >= MAX_TBL_CFG) || (defCfgParam[DEF_TABLE_ID] == 0) || (defCfgParam[DEF_TABLE_ID] > MAX_TBL_CFG))
            {
                respStatus = CMD_INVALID_TABLE_ID;
                break;
            }

            if ((defCfgParam[DEF_FROM_INDEX_ID] == 0) || (defCfgParam[DEF_TO_INDEX_ID] == 0)
                    || (defCfgParam[DEF_FROM_INDEX_ID] > (UINT64)totalIndexPerEveryTable[totalIndexId])
                    || (defCfgParam[DEF_TO_INDEX_ID] > (UINT64)totalIndexPerEveryTable[totalIndexId]))
            {
                respStatus = CMD_INVALID_INDEX_ID;
                break;
            }

            if (defCfgParam[DEF_FROM_INDEX_ID] > defCfgParam[DEF_TO_INDEX_ID])
            {
                respStatus = CMD_INVALID_INDEX_RANGE;
                break;
            }

            // Adjust index
            defCfgParam[DEF_TABLE_ID] = CLIENT_TO_OUR_INDEX(defCfgParam[DEF_TABLE_ID]);
            defCfgParam[DEF_FROM_INDEX_ID] = CLIENT_TO_OUR_INDEX(defCfgParam[DEF_FROM_INDEX_ID]);
            defCfgParam[DEF_TO_INDEX_ID] = CLIENT_TO_OUR_INDEX(defCfgParam[DEF_TO_INDEX_ID]);
            DPRINT(NETWORK_MANAGER, "[table=%lld], [index=%lld -> %lld]",
                   defCfgParam[DEF_TABLE_ID], defCfgParam[DEF_FROM_INDEX_ID], defCfgParam[DEF_TO_INDEX_ID]);

            // increment source pointer to next table request, if any, or EOM
            source++;
            if (defCfgFuncPtr[defCfgParam[DEF_TABLE_ID]] == NULL)
            {
                respStatus = CMD_PROCESS_ERROR;
                break;
            }

            respStatus = defCfgFuncPtr[defCfgParam[DEF_TABLE_ID]](defCfgParam[DEF_FROM_INDEX_ID], defCfgParam[DEF_TO_INDEX_ID]);
            if (respStatus != CMD_SUCCESS)
            {
                break;
            }

            GET_EVENT_CONFIG_DETAIL(eventDetail, MAX_EVENT_DETAIL_SIZE, defCfgParam[DEF_TABLE_ID]);
            WriteEvent(LOG_USER_EVENT, LOG_CONFIG_CHANGE, eventDetail, advncDetail, EVENT_CFGDFLT);
		}
	}

	// compose get configuration reply header SOM HEADER FSP
    outLen = snprintf(replyMsg, MAX_REPLY_SZ, "%c%s%c%d%c%c", SOM, headerReq[RPL_CFG], FSP, respStatus, FSP, EOM);
    sendCmdCb[callbackType](connFd, (UINT8PTR)replyMsg, outLen, MESSAGE_REPLY_TIMEOUT);
    return SUCCESS;
}

/** ******************************************************************************************* **/
/**                                  GENERAL SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getGeneralCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr,  const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	GENERAL_CONFIG_t 	generalCfg;
    UINT16				outLen;

	ReadGeneralConfig(&generalCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case GEN_CFG_DEVICE_NAME:
                PRINT_STRING(generalCfg.deviceName);
                break;

            case GEN_CFG_FILE_RECORD_DURATION:
                PRINT_INT(generalCfg.fileRecordDuration);
                break;

            case GEN_CFG_AUTO_LOGOUT_DURATION:
                PRINT_INT(generalCfg.autoLogoutDuration);
                break;

            case GEN_CFG_AUTO_POWER_ON:
                PRINT_INT(generalCfg.autoPowerOn);
                break;

            case GEN_CFG_HTTP_PORT:
                PRINT_INT(generalCfg.httpPort);
                break;

            case GEN_CFG_TCP_PORT:
                PRINT_INT(generalCfg.tcpPort);
                break;

            case GEN_CFG_RTP_PORT_START:
                PRINT_INT(generalCfg.rtpPort.start);
                break;

            case GEN_CFG_RTP_PORT_END:
                PRINT_INT(generalCfg.rtpPort.end);
                break;

            case GEN_CFG_ONVIF_PORT:
                PRINT_INT(generalCfg.onvifPort);
                break;

            case GEN_CFG_DEVICE_ID:
                PRINT_INT(generalCfg.deviceId);
                break;

            case GEN_CFG_VIDEO_SYSTEM_TYPE:
                PRINT_INT(generalCfg.videoSystemType);
                break;

            case GEN_CFG_COSEC_RECORDING:
                PRINT_INT(generalCfg.integrateCosec);
                break;

            case GEN_CFG_DATE_FORMAT:
                PRINT_INT(generalCfg.dateFormat);
                break;

            case GEN_CFG_TIME_FORMAT:
                PRINT_INT(generalCfg.timeFormat);
                break;

            case GEN_CFG_RECORD_FORMAT:
                PRINT_INT(generalCfg.recordFormatType);
                break;

            case GEN_CFG_ANALOG_CAM_NO:
                PRINT_INT(generalCfg.analogCamNo);
                break;

            case GEN_CFG_IP_CAM_NO:
                PRINT_INT(generalCfg.ipCamNo);
                break;

            case GEN_CFG_AUTO_CONFIG_FLAG:
                PRINT_INT(generalCfg.autoConfigureCameraFlag);
                break;

            case GEN_CFG_IP_RETAIN_FLAG:
                PRINT_INT(generalCfg.retainIpAddresses);
                break;

            case GEN_CFG_AUTO_CONFIG_START_IP:
                PRINT_STRING(generalCfg.autoConfigStartIp);
                break;

            case GEN_CFG_AUTO_CONFIG_END_IP:
                PRINT_STRING(generalCfg.autoConfigEndIp);
                break;

            case GEN_CFG_PROFILR_RETAIN_FLAG:
                PRINT_INT(generalCfg.retainDfltProfile);
                break;

            case GEN_CFG_MAIN_STREAM_VIDEO_ENCODING:
                PRINT_STRING(generalCfg.videoEncoding);
                break;

            case GEN_CFG_MAIN_STREAM_FRAMERATE:
                PRINT_INT(generalCfg.framerate);
                break;

            case GEN_CFG_MAIN_STREAM_RESOLUTION:
                PRINT_STRING(generalCfg.resolution);
                break;

            case GEN_CFG_MAIN_STREAM_BITRATE_MODE:
                PRINT_INT(generalCfg.bitrateMode);
                break;

            case GEN_CFG_MAIN_STREAM_BITRATE_VALUE:
                PRINT_INT(generalCfg.bitrateValue);
                break;

            case GEN_CFG_MAIN_STREAM_QUALITY:
                PRINT_INT(generalCfg.quality);
                break;

            case GEN_CFG_MAIN_STREAM_GOP:
                PRINT_INT(generalCfg.gop);
                break;

            case GEN_CFG_MAIN_STREAM_ENABLE_AUDIO:
                PRINT_INT(generalCfg.enableAudio);
                break;

            case GEN_CFG_SUB_STREAM_VIDEO_ENCODING:
                PRINT_STRING(generalCfg.videoEncodingSub);
                break;

            case GEN_CFG_SUB_STREAM_FRAMERATE:
                PRINT_INT(generalCfg.framerateSub);
                break;

            case GEN_CFG_SUB_STREAM_RESOLUTION:
                PRINT_STRING(generalCfg.resolutionSub);
                break;

            case GEN_CFG_SUB_STREAM_BITRATE_MODE:
                PRINT_INT(generalCfg.bitrateModeSub);
                break;

            case GEN_CFG_SUB_STREAM_BITRATE_VALUE:
                PRINT_INT(generalCfg.bitrateValueSub);
                break;

            case GEN_CFG_SUB_STREAM_QUALITY:
                PRINT_INT(generalCfg.qualitySub);
                break;

            case GEN_CFG_SUB_STREAM_GOP:
                PRINT_INT(generalCfg.gopSub);
                break;

            case GENCFG_SUB_STREAM_ENABLE_AUDIO:
                PRINT_INT(generalCfg.enableAudioSub);
                break;

            case GEN_CFG_DI_ACTIVE_FLAG:
                PRINT_INT(generalCfg.devInitWithServerF);
                break;

            case GEN_CFG_DI_SERVER_IP:
                PRINT_STRING(generalCfg.devInitServerIpAddr);
                break;

            case GEN_CFG_DI_SERVER_PORT:
                PRINT_INT(generalCfg.devInitServerPort);
                break;

            case GEN_CFG_AUTO_REC_FAIL_ALERT:
                PRINT_INT(generalCfg.autoRecordFailFlag);
                break;

            case GEN_CFG_VIDEO_POPUP_DURATION:
                PRINT_INT(generalCfg.videoPopupDuration);
                break;

            case GEN_CFG_PRE_VIDEO_LOSS_DURATION:
                PRINT_INT(generalCfg.preVideoLossDuration);
                break;

            case GEN_CFG_USER_NAME:
                PRINT_STRING(generalCfg.userName);
                break;

            case GEN_CFG_PASSWORD:
                PRINT_STRING(generalCfg.password);
                break;

            case GEN_CFG_START_LIVE_VIEW_FLAG:
                PRINT_INT(generalCfg.startLiveView);
                break;

            case GEN_CFG_FORWARDED_TCP_PORT:
                PRINT_INT(generalCfg.forwardedTcpPort);
                break;

            case GEN_CFG_AUTO_ADD_CAM_FLAG:
                PRINT_INT(generalCfg.autoAddCamFlag);
                break;

            case GEN_CFG_AUTO_ADD_CAM_TCP_PORT:
                PRINT_INT(generalCfg.autoAddCamTcpPort);
                break;

            case GEN_CFG_POLL_DURATION:
                PRINT_INT(generalCfg.pollDuration);
                break;

            case GEN_CFG_POLL_INTERVAL:
                PRINT_INT(generalCfg.pollInterval);
                break;

            case GEN_CFG_NET_ACCELERATION:
                PRINT_INT(generalCfg.netAcceleration);
                break;

            default:
                break;
		}

        //Validate buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setGeneralCfg(CHARPTR *reqStr)
{
	GENERAL_CONFIG_t 	generalCfg;
	UINT64 				fieldId = 0;
	UINT64 				indexId = 0;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	while (**reqStr != EOT)
	{
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_GENERAL_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadGeneralConfig(&generalCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case GEN_CFG_DEVICE_NAME:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.deviceName, sizeof(generalCfg.deviceName));
                    break;

                case GEN_CFG_FILE_RECORD_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.fileRecordDuration = fieldVal;
                    break;

                case GEN_CFG_HTTP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.httpPort = fieldVal;
                    break;

                case GEN_CFG_TCP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.tcpPort = fieldVal;
                    break;

                case GEN_CFG_RTP_PORT_START:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.rtpPort.start =  fieldVal;
                    break;

                case GEN_CFG_RTP_PORT_END:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.rtpPort.end = fieldVal;
                    break;

                case GEN_CFG_DEVICE_ID:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.deviceId = fieldVal;
                    break;

                case GEN_CFG_COSEC_RECORDING:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.integrateCosec = fieldVal;
                    break;

                case GEN_CFG_DATE_FORMAT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.dateFormat = fieldVal;
                    break;

                case GEN_CFG_TIME_FORMAT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.timeFormat = fieldVal;
                    break;

                case GEN_CFG_RECORD_FORMAT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.recordFormatType = fieldVal;
                    break;

                case GEN_CFG_AUTO_CONFIG_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.autoConfigureCameraFlag = fieldVal;
                    break;

                case GEN_CFG_IP_RETAIN_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.retainIpAddresses = fieldVal;
                    break;

                case GEN_CFG_AUTO_CONFIG_START_IP:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.autoConfigStartIp, sizeof(generalCfg.autoConfigStartIp));
                    break;

                case GEN_CFG_AUTO_CONFIG_END_IP:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.autoConfigEndIp, sizeof(generalCfg.autoConfigEndIp));
                    break;

                case GEN_CFG_PROFILR_RETAIN_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.retainDfltProfile = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_VIDEO_ENCODING:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.videoEncoding, sizeof(generalCfg.videoEncoding));
                    break;

                case GEN_CFG_MAIN_STREAM_FRAMERATE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.framerate = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_RESOLUTION:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.resolution, sizeof(generalCfg.resolution));
                    break;

                case GEN_CFG_MAIN_STREAM_BITRATE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.bitrateMode = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_BITRATE_VALUE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.bitrateValue = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_QUALITY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.quality = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_GOP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.gop = fieldVal;
                    break;

                case GEN_CFG_MAIN_STREAM_ENABLE_AUDIO:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.enableAudio = fieldVal;
                    break;

                case GEN_CFG_SUB_STREAM_VIDEO_ENCODING:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.videoEncodingSub, sizeof(generalCfg.videoEncodingSub));
                    break;

                case GEN_CFG_SUB_STREAM_FRAMERATE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.framerateSub = fieldVal;
                    break;

                case GEN_CFG_SUB_STREAM_RESOLUTION:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.resolutionSub, sizeof(generalCfg.resolutionSub));
                    break;

                case GEN_CFG_SUB_STREAM_BITRATE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.bitrateModeSub = fieldVal;
                    break;

                case GEN_CFG_SUB_STREAM_BITRATE_VALUE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.bitrateValueSub = fieldVal;
                    break;

                case GEN_CFG_SUB_STREAM_QUALITY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.qualitySub = fieldVal;
                    break;

                case GEN_CFG_SUB_STREAM_GOP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.gopSub = fieldVal;
                    break;

                case GENCFG_SUB_STREAM_ENABLE_AUDIO:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.enableAudioSub = fieldVal;
                    break;

                case GEN_CFG_DI_ACTIVE_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.devInitWithServerF = (BOOL)fieldVal;
                    break;

                case GEN_CFG_DI_SERVER_IP:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.devInitServerIpAddr, sizeof(generalCfg.devInitServerIpAddr));
                    break;

                case GEN_CFG_DI_SERVER_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.devInitServerPort = (UINT16)fieldVal;
                    break;

                case GEN_CFG_AUTO_REC_FAIL_ALERT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.autoRecordFailFlag = fieldVal;
                    break;

                case GEN_CFG_VIDEO_POPUP_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.videoPopupDuration = fieldVal;
                    break;

                case GEN_CFG_PRE_VIDEO_LOSS_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.preVideoLossDuration = fieldVal;
                    break;

                case GEN_CFG_USER_NAME:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.userName, sizeof(generalCfg.userName));
                    break;

                case GEN_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, generalCfg.password, sizeof(generalCfg.password));
                    break;

                case GEN_CFG_START_LIVE_VIEW_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.startLiveView = (BOOL)fieldVal;
                    break;

                case GEN_CFG_FORWARDED_TCP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.forwardedTcpPort = fieldVal;
                    break;

                case GEN_CFG_AUTO_ADD_CAM_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.autoAddCamFlag = (BOOL)fieldVal;
                    break;

                case GEN_CFG_AUTO_ADD_CAM_TCP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.autoAddCamTcpPort = fieldVal;
                    break;

                case GEN_CFG_POLL_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.pollDuration = fieldVal;
                    break;

                case GEN_CFG_POLL_INTERVAL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    generalCfg.pollInterval = fieldVal;
                    break;

                /* Unused config field id list */
                case GEN_CFG_AUTO_LOGOUT_DURATION:
                case GEN_CFG_AUTO_POWER_ON:
                case GEN_CFG_ONVIF_PORT:
                case GEN_CFG_VIDEO_SYSTEM_TYPE:
                case GEN_CFG_ANALOG_CAM_NO:
                case GEN_CFG_IP_CAM_NO:
                case GEN_CFG_NET_ACCELERATION:
                    ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteGeneralConfig(&generalCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defGeneralCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltGeneralConfig();
}

/** ******************************************************************************************* **/
/**                                DATE-TIME SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getDateTimeCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	DATE_TIME_CONFIG_t 	dateTimeCfg;
    UINT16				outLen;

	ReadDateTimeConfig(&dateTimeCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case DATE_TIME_CFG_TIMEZONE:
                PRINT_INT(dateTimeCfg.timezone);
                break;

            case DATE_TIME_CFG_UPDATE_MODE:
                PRINT_INT(dateTimeCfg.updateMode);
                break;

            case DATE_TIME_CFG_NTP_SERVER:
                PRINT_INT(dateTimeCfg.ntp.server);
                break;

            case DATE_TIME_CFG_USER_DEFINED_SERVER:
                PRINT_STRING(dateTimeCfg.ntp.userDefinedServer);
                break;

            case DATE_TIME_CFG_UPDATE_INTERVAL:
                PRINT_INT(dateTimeCfg.ntp.updateInterval);
                break;

            case DATE_TIME_CFG_AUTO_UPDATE_REGIONAL:
                PRINT_INT(dateTimeCfg.autoUpdateRegional);
                break;

            case DATE_TIME_CFG_AUTO_SYNC_TIMEZONE:
                PRINT_INT(dateTimeCfg.syncTimeZoneToOnvifCam);
                break;

            case DATE_TIME_CFG_SET_UTC_TIME:
                PRINT_INT(dateTimeCfg.setUtcTime);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setDateTimeCfg(CHARPTR *reqStr)
{
	DATE_TIME_CONFIG_t 	dateTimeCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_DATE_TIME_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadDateTimeConfig(&dateTimeCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case DATE_TIME_CFG_TIMEZONE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.timezone = fieldVal;
                    break;

                case DATE_TIME_CFG_UPDATE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.updateMode = fieldVal;
                    break;

                case DATE_TIME_CFG_NTP_SERVER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.ntp.server = fieldVal;
                    break;

                case DATE_TIME_CFG_USER_DEFINED_SERVER:
                    writeStatus = ParseStr(reqStr, FSP, dateTimeCfg.ntp.userDefinedServer, sizeof(dateTimeCfg.ntp.userDefinedServer));
                    break;

                case DATE_TIME_CFG_UPDATE_INTERVAL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.ntp.updateInterval = fieldVal;
                    break;

                case DATE_TIME_CFG_AUTO_UPDATE_REGIONAL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.autoUpdateRegional = fieldVal;
                    break;

                case DATE_TIME_CFG_AUTO_SYNC_TIMEZONE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.syncTimeZoneToOnvifCam = fieldVal;
                    break;

                case DATE_TIME_CFG_SET_UTC_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dateTimeCfg.setUtcTime = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteDateTimeConfig(&dateTimeCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defDateTimeCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltDateTimeConfig();
}

/** ******************************************************************************************* **/
/**                                    DST SETTINGS                                             **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getDstCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16          fieldLoop;
    DST_CONFIG_t    dstCfg;
    UINT16          outLen;

	ReadDstConfig(&dstCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case DST_CFG_DST:
                PRINT_INT(dstCfg.dst);
                break;

            case DST_CFG_FORWARD_CLK_DAY_MONTH:
                PRINT_INT(dstCfg.forwardClock.day.month);
                break;

            case DST_CFG_FORWARD_CLK_DAY_WEEK:
                PRINT_INT(dstCfg.forwardClock.day.week);
                break;

            case DST_CFG_FORWARD_CLK_DAY_WEEKDAY:
                PRINT_INT(dstCfg.forwardClock.day.weekDay);
                break;

            case DST_CFG_FORWARD_CLK_INSTATNCE:
                PRINT_TIME(dstCfg.forwardClock.instance);
                break;

            case DST_CFG_REVERSE_CLK_DAY_MONTH:
                PRINT_INT(dstCfg.reverseClock.day.month);
                break;

            case DST_CFG_REVERSE_CLK_DAY_WEEK:
                PRINT_INT(dstCfg.reverseClock.day.week);
                break;

            case DST_CFG_REVERSE_CLK_DAY_WEEKDAY:
                PRINT_INT(dstCfg.reverseClock.day.weekDay);
                break;

            case DST_CFG_REVERSE_CLK_INSTATNCE:
                PRINT_TIME(dstCfg.reverseClock.instance);
                break;

            case DST_CFG_PERIOD:
                PRINT_TIME(dstCfg.period);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setDstCfg(CHARPTR *reqStr)
{
	DST_CONFIG_t 		dstCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_DST_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadDstConfig(&dstCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case DST_CFG_DST:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.dst = fieldVal;
                    break;

                case DST_CFG_FORWARD_CLK_DAY_MONTH:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.forwardClock.day.month = fieldVal;
                    break;

                case DST_CFG_FORWARD_CLK_DAY_WEEK:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.forwardClock.day.week = fieldVal;
                    break;

                case DST_CFG_FORWARD_CLK_DAY_WEEKDAY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.forwardClock.day.weekDay = fieldVal;
                    break;

                case DST_CFG_FORWARD_CLK_INSTATNCE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.forwardClock.instance.minute = fieldVal % 100;
                    dstCfg.forwardClock.instance.hour = fieldVal / 100;
                    break;

                case DST_CFG_REVERSE_CLK_DAY_MONTH:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.reverseClock.day.month = fieldVal;
                    break;

                case DST_CFG_REVERSE_CLK_DAY_WEEK:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.reverseClock.day.week = fieldVal;
                    break;

                case DST_CFG_REVERSE_CLK_DAY_WEEKDAY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.reverseClock.day.weekDay = fieldVal;
                    break;

                case DST_CFG_REVERSE_CLK_INSTATNCE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.reverseClock.instance.minute = fieldVal % 100;
                    dstCfg.reverseClock.instance.hour = fieldVal / 100;
                    break;

                case DST_CFG_PERIOD:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dstCfg.period.minute = fieldVal % 100;
                    dstCfg.period.hour = fieldVal / 100;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteDstConfig(&dstCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defDstCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltDstConfig();
}

/** ******************************************************************************************* **/
/**                                     LAN1 SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getLan1Cfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16          fieldLoop;
    LAN_CONFIG_t    lan1Cfg = { 0 };
    UINT16          outLen;

    if(SUCCESS != ReadLan1ConfigCms(&lan1Cfg))
    {
        EPRINT(NETWORK_MANAGER, "fail to get lan1 config");
    }

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case LAN_1_CFG_IPV4_ASSIGN_MODE:
                PRINT_INT(lan1Cfg.ipv4.ipAssignMode);
                break;

            case LAN_1_CFG_LAN_IPV4_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv4.lan.ipAddress);
                break;

            case LAN_1_CFG_LAN_IPV4_SUBNET_MASK:
                PRINT_STRING(lan1Cfg.ipv4.lan.subnetMask);
                break;

            case LAN_1_CFG_LAN_IPV4_GATEWAY:
                PRINT_STRING(lan1Cfg.ipv4.lan.gateway);
                break;

            case LAN_1_CFG_PPPOE_USERNAME:
                PRINT_STRING(lan1Cfg.ipv4.pppoe.username);
                break;

            case LAN_1_CFG_PPPOE_PASSWORD:
                PRINT_STRING(lan1Cfg.ipv4.pppoe.password);
                break;

            case LAN_1_CFG_DNSV4_MODE:
                PRINT_INT(lan1Cfg.ipv4.dns.mode);
                break;

            case LAN_1_CFG_DNSV4_PRIMARY_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv4.dns.primaryAddress);
                break;

            case LAN_1_CFG_DNSV4_SECONDARY_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv4.dns.secondaryAddress);
                break;

            case LAN_1_CFG_ADDR_MODE:
                PRINT_INT(lan1Cfg.ipAddrMode);
                break;

            case LAN_1_CFG_IPV6_ASSIGN_MODE:
                PRINT_INT(lan1Cfg.ipv6.ipAssignMode);
                break;

            case LAN_1_CFG_LAN_IPV6_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv6.lan.ipAddress);
                break;

            case LAN_1_CFG_LAN_PREFIX_LEN:
                PRINT_INT(lan1Cfg.ipv6.lan.prefixLen);
                break;

            case LAN_1_CFG_LAN_IPV6_GATEWAY:
                PRINT_STRING(lan1Cfg.ipv6.lan.gateway);
                break;

            case LAN_1_CFG_DNSV6_MODE:
                PRINT_INT(lan1Cfg.ipv6.dns.mode);
                break;

            case LAN_1_CFG_DNSV6_PRIMARY_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv6.dns.primaryAddress);
                break;

            case LAN_1_CFG_DNSV6_SECONDARY_ADDRESS:
                PRINT_STRING(lan1Cfg.ipv6.dns.secondaryAddress);
                break;

            default:
                break;
		}
        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setLan1Cfg(CHARPTR *reqStr)
{
	LAN_CONFIG_t		lan1Cfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_LAN1_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadLan1ConfigCms(&lan1Cfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case LAN_1_CFG_IPV4_ASSIGN_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipv4.ipAssignMode = fieldVal;
                    break;

                case LAN_1_CFG_LAN_IPV4_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.lan.ipAddress, sizeof(lan1Cfg.ipv4.lan.ipAddress));
                    break;

                case LAN_1_CFG_LAN_IPV4_SUBNET_MASK:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.lan.subnetMask, sizeof(lan1Cfg.ipv4.lan.subnetMask));
                    break;

                case LAN_1_CFG_LAN_IPV4_GATEWAY:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.lan.gateway, sizeof(lan1Cfg.ipv4.lan.gateway));
                    break;

                case LAN_1_CFG_PPPOE_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.pppoe.username, sizeof(lan1Cfg.ipv4.pppoe.username));
                    break;

                case LAN_1_CFG_PPPOE_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.pppoe.password, sizeof(lan1Cfg.ipv4.pppoe.password));
                    break;

                case LAN_1_CFG_DNSV4_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipv4.dns.mode = fieldVal;
                    break;

                case LAN_1_CFG_DNSV4_PRIMARY_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.dns.primaryAddress, sizeof(lan1Cfg.ipv4.dns.primaryAddress));
                    break;

                case LAN_1_CFG_DNSV4_SECONDARY_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv4.dns.secondaryAddress, sizeof(lan1Cfg.ipv4.dns.secondaryAddress));
                    break;

                case LAN_1_CFG_ADDR_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipAddrMode = fieldVal;
                    break;

                case LAN_1_CFG_IPV6_ASSIGN_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipv6.ipAssignMode = fieldVal;
                    break;

                case LAN_1_CFG_LAN_IPV6_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv6.lan.ipAddress, sizeof(lan1Cfg.ipv6.lan.ipAddress));
                    break;

                case LAN_1_CFG_LAN_PREFIX_LEN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipv6.lan.prefixLen = fieldVal;
                    break;

                case LAN_1_CFG_LAN_IPV6_GATEWAY:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv6.lan.gateway, sizeof(lan1Cfg.ipv6.lan.gateway));
                    break;

                case LAN_1_CFG_DNSV6_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan1Cfg.ipv6.dns.mode = fieldVal;
                    break;

                case LAN_1_CFG_DNSV6_PRIMARY_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv6.dns.primaryAddress, sizeof(lan1Cfg.ipv6.dns.primaryAddress));
                    break;

                case LAN_1_CFG_DNSV6_SECONDARY_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan1Cfg.ipv6.dns.secondaryAddress, sizeof(lan1Cfg.ipv6.dns.secondaryAddress));
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteLan1Config(&lan1Cfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
    (*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defLan1Cfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltLan1Config();
}

/** ******************************************************************************************* **/
/**                                     LAN2 SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getLan2Cfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16          fieldLoop;
    LAN_CONFIG_t    lan2Cfg = {0};
    UINT16          outLen;

    ReadLan2ConfigCms(&lan2Cfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case LAN_2_CFG_IPV4_ADDRESS:
                PRINT_STRING(lan2Cfg.ipv4.lan.ipAddress);
                break;

            case LAN_2_CFG_IPV4_SUBNET_MASK:
                PRINT_STRING(lan2Cfg.ipv4.lan.subnetMask);
                break;

            case LAN_2_CFG_IPV4_GATEWAY:
                PRINT_STRING(lan2Cfg.ipv4.lan.gateway);
                break;

            case LAN_2_CFG_ADDR_MODE:
                PRINT_INT(lan2Cfg.ipAddrMode);
                break;

            case LAN_2_CFG_LAN_IPV6_ADDRESS:
                PRINT_STRING(lan2Cfg.ipv6.lan.ipAddress);
                break;

            case LAN_2_CFG_LAN_PREFIX_LEN:
                PRINT_INT(lan2Cfg.ipv6.lan.prefixLen);
                break;

            case LAN_2_CFG_LAN_IPV6_GATEWAY:
                PRINT_STRING(lan2Cfg.ipv6.lan.gateway);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setLan2Cfg(CHARPTR *reqStr)
{
	LAN_CONFIG_t		lan2Cfg;
	UINT64 				fieldId;
    UINT64 				fieldVal = 0;
	UINT64 				indexId;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_LAN2_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadLan2ConfigCms(&lan2Cfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case LAN_2_CFG_IPV4_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan2Cfg.ipv4.lan.ipAddress, sizeof(lan2Cfg.ipv4.lan.ipAddress));
                    break;

                case LAN_2_CFG_IPV4_SUBNET_MASK:
                    writeStatus = ParseStr(reqStr, FSP, lan2Cfg.ipv4.lan.subnetMask, sizeof(lan2Cfg.ipv4.lan.subnetMask));
                    break;

                case LAN_2_CFG_IPV4_GATEWAY:
                    writeStatus = ParseStr(reqStr, FSP, lan2Cfg.ipv4.lan.gateway, sizeof(lan2Cfg.ipv4.lan.gateway));
                    break;

                case LAN_2_CFG_ADDR_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan2Cfg.ipAddrMode = fieldVal;
                    break;

                case LAN_2_CFG_LAN_IPV6_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, lan2Cfg.ipv6.lan.ipAddress, sizeof(lan2Cfg.ipv6.lan.ipAddress));
                    break;

                case LAN_2_CFG_LAN_PREFIX_LEN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    lan2Cfg.ipv6.lan.prefixLen = fieldVal;
                    break;

                case LAN_2_CFG_LAN_IPV6_GATEWAY:
                    writeStatus = ParseStr(reqStr, FSP, lan2Cfg.ipv6.lan.gateway, sizeof(lan2Cfg.ipv6.lan.gateway));
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteLan2Config(&lan2Cfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defLan2Cfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltLan2Config();
}

/** ******************************************************************************************* **/
/**                                  IP FILTER SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getIPFilterEnableCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	IP_FILTER_CONFIG_t	ipFilterCfg;
    UINT16				outLen;

    ReadIpFilterConfig(&ipFilterCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case IP_FILTER_ENABLE_CFG_IP_FILTER:
                PRINT_INT(ipFilterCfg.ipFilter);
                break;

            case IP_FILTER_ENABLE_CFG_FILTER_MODE:
                PRINT_INT(ipFilterCfg.mode);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setIPFilterEnableCfg(CHARPTR *reqStr)
{
	IP_FILTER_CONFIG_t	ipFilterCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_IP_FILTER_ENABLE_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadIpFilterConfig(&ipFilterCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);

            switch(fieldId)
            {
                case IP_FILTER_ENABLE_CFG_IP_FILTER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipFilterCfg.ipFilter = fieldVal;
                    break;

                case IP_FILTER_ENABLE_CFG_FILTER_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipFilterCfg.mode = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteIpFilterConfig(&ipFilterCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defIPFilterEnableCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltIpFilterConfig();
}

static NET_CMD_STATUS_e getIPFilterCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	UINT16				indexLoop;
	IP_FILTER_CONFIG_t	ipFilterCfg;
	UINT16				outLen = 0;

	ReadIpFilterConfig(&ipFilterCfg);
	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case IP_FILTER_CFG_START_ADDRESS:
                    PRINT_STRING(ipFilterCfg.filter[indexLoop].startAddress);
                    break;

                case IP_FILTER_CFG_END_ADDRESS:
                    PRINT_STRING(ipFilterCfg.filter[indexLoop].endAddress);
                    break;

                default:
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;

        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setIPFilterCfg(CHARPTR *reqStr)
{
	IP_FILTER_CONFIG_t	ipFilterCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	ReadIpFilterConfig(&ipFilterCfg);

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_IP_FILTER_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);

            switch(fieldId)
            {
                case IP_FILTER_CFG_START_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, ipFilterCfg.filter[indexId].startAddress, sizeof(ipFilterCfg.filter[indexId].startAddress));
                    break;

                case IP_FILTER_CFG_END_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, ipFilterCfg.filter[indexId].endAddress, sizeof(ipFilterCfg.filter[indexId].endAddress));
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
		{
			break;
		}
	}

	// increment for EOT
	(*reqStr)++;

	// As this has inner index, write at the end
    if (writeStatus == SUCCESS)
	{
		retVal = WriteIpFilterConfig(&ipFilterCfg);
	}

	return retVal;
}

static NET_CMD_STATUS_e defIPFilterCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltIpFilterConfig();
}

/** ******************************************************************************************* **/
/**                                     DDNS SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getDdnsCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	DDNS_CONFIG_t		ddnsCfg;
    UINT16				outLen;

	ReadDdnsConfig(&ddnsCfg);

	//Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case DDNS_CFG_DDNS:
                PRINT_INT(ddnsCfg.ddns);
                break;

            case DDNS_CFG_SERVER:
                PRINT_INT(ddnsCfg.server);
                break;

            case DDNS_CFG_USERNAME:
                PRINT_STRING(ddnsCfg.username);
                break;

            case DDNS_CFG_PASSWORD:
                PRINT_STRING(ddnsCfg.password);
                break;

            case DDNS_CFG_HOSTNAME:
                PRINT_STRING(ddnsCfg.hostname);
                break;

            case DDNS_CFG_UPDATE_DURATION:
                PRINT_INT(ddnsCfg.updateDuration);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setDdnsCfg(CHARPTR *reqStr)
{
	DDNS_CONFIG_t		ddnsCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_DDNS_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadDdnsConfig(&ddnsCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case DDNS_CFG_DDNS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ddnsCfg.ddns = fieldVal;
                    break;

                case DDNS_CFG_SERVER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ddnsCfg.server = fieldVal;
                    break;

                case DDNS_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, ddnsCfg.username, sizeof(ddnsCfg.username));
                    break;

                case DDNS_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, ddnsCfg.password, sizeof(ddnsCfg.password));
                    break;

                case DDNS_CFG_HOSTNAME:
                    writeStatus = ParseStr(reqStr, FSP, ddnsCfg.hostname, sizeof(ddnsCfg.hostname));
                    break;

                case DDNS_CFG_UPDATE_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ddnsCfg.updateDuration = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteDdnsConfig(&ddnsCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defDdnsCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltDdnsConfig();
}

/** ******************************************************************************************* **/
/**                                 SMTP(EMAIL) SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSmtpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16          fieldLoop;
    SMTP_CONFIG_t   smtpCfg;
    UINT16          outLen;

	ReadSmtpConfig(&smtpCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case SMTP_CFG_SMTP:
                PRINT_INT(smtpCfg.smtp);
                break;

            case SMTP_CFG_SERVER:
                PRINT_STRING(smtpCfg.server);
                break;

            case SMTP_CFG_SERVER_PORT:
                PRINT_INT(smtpCfg.serverPort);
                break;

            case SMTP_CFG_USERNAME:
                PRINT_STRING(smtpCfg.username);
                break;

            case SMTP_CFG_PASSWORD:
                PRINT_STRING(smtpCfg.password);
                break;

            case SMTP_CFG_SENDOR_ADDRESS:
                PRINT_STRING(smtpCfg.senderAddress);
                break;

            case SMTP_CFG_SSL:
                PRINT_INT(smtpCfg.encryptionType);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setSmtpCfg(CHARPTR *reqStr)
{
	SMTP_CONFIG_t		smtpCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_SMTP_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadSmtpConfig(&smtpCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);

            switch(fieldId)
            {
                case SMTP_CFG_SMTP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    smtpCfg.smtp = fieldVal;
                    break;

                case SMTP_CFG_SERVER:
                    writeStatus = ParseStr(reqStr, FSP, smtpCfg.server, sizeof(smtpCfg.server));
                    break;

                case SMTP_CFG_SERVER_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    smtpCfg.serverPort = fieldVal;
                    break;

                case SMTP_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, smtpCfg.username, sizeof(smtpCfg.username));
                    break;

                case SMTP_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, smtpCfg.password, sizeof(smtpCfg.password));
                    break;

                case SMTP_CFG_SENDOR_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, smtpCfg.senderAddress, sizeof(smtpCfg.senderAddress));
                    break;

                case SMTP_CFG_SSL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    smtpCfg.encryptionType = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSmtpConfig(&smtpCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defSmtpCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltSmtpConfig();
}

/** ******************************************************************************************* **/
/**                                  FTP UPLOAD SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getFtpUploadCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	UINT16				indexLoop;
	FTP_UPLOAD_CONFIG_t	ftpUploadCfg;
	UINT16				outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleFtpUploadConfig(indexLoop, &ftpUploadCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case FTP_UPLOAD_CFG_FTP:
                    PRINT_INT(ftpUploadCfg.ftp);
                    break;

                case FTP_UPLOAD_CFG_SERVER:
                    PRINT_STRING(ftpUploadCfg.server);
                    break;

                case FTP_UPLOAD_CFG_SERVER_PORT:
                    PRINT_INT(ftpUploadCfg.serverPort);
                    break;

                case FTP_UPLOAD_CFG_USERNAME:
                    PRINT_STRING(ftpUploadCfg.username);
                    break;

                case FTP_UPLOAD_CFG_PASSWORD:
                    PRINT_STRING(ftpUploadCfg.password);
                    break;

                case FTP_UPLOAD_CFG_UPLOAD_PATH:
                    PRINT_STRING(ftpUploadCfg.uploadPath);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setFtpUploadCfg(CHARPTR *reqStr)
{
	FTP_UPLOAD_CONFIG_t	ftpUploadCfg;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId;
	UINT64				fieldId;
	UINT64				fieldVal = 0;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_FTP_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleFtpUploadConfig(indexId, &ftpUploadCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case FTP_UPLOAD_CFG_FTP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ftpUploadCfg.ftp = fieldVal;
                    break;

                case FTP_UPLOAD_CFG_SERVER:
                    writeStatus = ParseStr(reqStr, FSP, ftpUploadCfg.server, sizeof(ftpUploadCfg.server));
                    break;

                case FTP_UPLOAD_CFG_SERVER_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ftpUploadCfg.serverPort = fieldVal;
                    break;

                case FTP_UPLOAD_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, ftpUploadCfg.username, sizeof(ftpUploadCfg.username));
                    break;

                case FTP_UPLOAD_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, ftpUploadCfg.password, sizeof(ftpUploadCfg.password));
                    break;

                case FTP_UPLOAD_CFG_UPLOAD_PATH:
                    writeStatus = ParseStr(reqStr, FSP, ftpUploadCfg.uploadPath, sizeof(ftpUploadCfg.uploadPath));
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleFtpUploadConfig(indexId, &ftpUploadCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defFtpUploadCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleFtpUploadConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                  TCP NOTIFY SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getTcpNotifyCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	TCP_NOTIFY_CONFIG_t	tcpNotifyCfg;
    UINT16				outLen;

	ReadTcpNotifyConfig(&tcpNotifyCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case TCP_NOTIFY_CFG_TCP_NOTIFY:
                PRINT_INT(tcpNotifyCfg.tcpNotify);
                break;

            case TCP_NOTIFY_CFG_SERVER:
                PRINT_STRING(tcpNotifyCfg.server);
                break;

            case TCP_NOTIFY_CFG_PORT:
                PRINT_INT(tcpNotifyCfg.serverPort);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setTcpNotifyCfg(CHARPTR *reqStr)
{
	TCP_NOTIFY_CONFIG_t	tcpNotifyCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_TCP_NOTIFY_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadTcpNotifyConfig(&tcpNotifyCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case TCP_NOTIFY_CFG_TCP_NOTIFY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    tcpNotifyCfg.tcpNotify = fieldVal;
                    break;

                case TCP_NOTIFY_CFG_SERVER:
                    writeStatus = ParseStr(reqStr, FSP, tcpNotifyCfg.server, sizeof(tcpNotifyCfg.server));
                    break;

                case TCP_NOTIFY_CFG_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    tcpNotifyCfg.serverPort = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteTcpNotifyConfig(&tcpNotifyCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defTcpNotifyCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltTcpNotifyConfig();
}

/** ******************************************************************************************* **/
/**                                    MEDIA FILE ACCESS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getFileAccessCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	FILE_ACCESS_CONFIG_t	fileAccessCfg;
	UINT16					outLen;

	ReadFileAccessConfig(&fileAccessCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
        {
            case FILE_ACCESS_CFG_FTP_ACCESS:
                PRINT_INT(fileAccessCfg.ftpAccess);
                break;

            case FILE_ACCESS_CFG_FTP_PORT:
                PRINT_INT(fileAccessCfg.ftpport);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setFileAccessCfg(CHARPTR *reqStr)
{
	FILE_ACCESS_CONFIG_t	fileAccessCfg;
	UINT64 					fieldId;
	UINT64 					indexId;
	UINT64 					fieldVal = 0;
    BOOL					writeStatus = SUCCESS;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_FILE_ACCESS_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadFileAccessConfig(&fileAccessCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case FILE_ACCESS_CFG_FTP_ACCESS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    fileAccessCfg.ftpAccess = fieldVal;
                    break;

                case FILE_ACCESS_CFG_FTP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    fileAccessCfg.ftpport = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL)  && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteFileAccessConfig(&fileAccessCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defFileAccessCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltFileAccessConfig();
}

/** ******************************************************************************************* **/
/**                                      HDD SETTINGS                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getHddCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	HDD_CONFIG_t		hddCfg;
    UINT16				outLen;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	ReadHddConfig(&hddCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case HDD_CFG_MODE:
                PRINT_INT(hddCfg.mode);
                break;

            case HDD_CFG_RECORD_DISK:
                PRINT_INT(hddCfg.recordDisk);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
	return retVal;
}

static NET_CMD_STATUS_e setHddCfg(CHARPTR *reqStr)
{
	HDD_CONFIG_t		hddCfg;
	UINT64 				fieldId;
	UINT64 				indexId;
	UINT64 				fieldVal = 0;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_HDD_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadHddConfig(&hddCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case HDD_CFG_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    hddCfg.mode = fieldVal;
                    break;

                case HDD_CFG_RECORD_DISK:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    hddCfg.recordDisk = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            retVal = CMD_PROCESS_ERROR;
            break;
        }

        retVal = WriteHddConfig(&hddCfg);
		if (retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defHddCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltHddConfig();
}

/** ******************************************************************************************* **/
/**                              MATRIX DNS SERVER SETTINGS                                     **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getMatrixDnsServerCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16						fieldLoop;
	MATRIX_DNS_SERVER_CONFIG_t	matrixDnsServerCfg;
    UINT16						outLen;

	ReadMatrixDnsServerConfig(&matrixDnsServerCfg);

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case MATRIX_DNS_SERVER_CFG_EN_MAC_CLIENT:
                PRINT_INT(matrixDnsServerCfg.enMacClient);
                break;

            case MATRIX_DNS_SERVER_CFG_HOST_NAME:
                PRINT_STRING(matrixDnsServerCfg.hostName);
                break;

            case MATRIX_DNS_SERVER_CFG_PORT:
                PRINT_INT(matrixDnsServerCfg.forwardedPort);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setMatrixDnsServerCfg(CHARPTR *reqStr)
{
	MATRIX_DNS_SERVER_CONFIG_t	matrixDnsServerCfg;
	UINT64 						fieldId;
	UINT64 						indexId;
	UINT64 						fieldVal = 0;
    BOOL						writeStatus = SUCCESS;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;

	// Loop till EOT
	while (**reqStr != EOT)
	{
		// must start with SOI
        if (**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        // Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_MATRIX_DNS_SERVER_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadMatrixDnsServerConfig(&matrixDnsServerCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case MATRIX_DNS_SERVER_CFG_EN_MAC_CLIENT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    matrixDnsServerCfg.enMacClient = fieldVal;
                    break;

                case MATRIX_DNS_SERVER_CFG_HOST_NAME:
                    writeStatus = ParseStr(reqStr, FSP, matrixDnsServerCfg.hostName, sizeof(matrixDnsServerCfg.hostName));
                    break;

                case MATRIX_DNS_SERVER_CFG_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    matrixDnsServerCfg.forwardedPort = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            retVal = CMD_PROCESS_ERROR;
            break;
        }

        retVal = WriteMatrixDnsServerConfig(&matrixDnsServerCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defMatrixDnsServerCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltMatrixDnsServerConfig();
}

/** ******************************************************************************************* **/
/**                                 USER ACCOUNT SETTINGS                                       **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getUserAccountCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	USER_ACCOUNT_CONFIG_t	userAccontCfg;
	UINT16					outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleUserAccountConfig(indexLoop, &userAccontCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case USER_ACCOUNT_CFG_USERNAME:
                    PRINT_STRING(userAccontCfg.username);
                    break;

                case USER_ACCOUNT_CFG_USERGROUP:
                    PRINT_INT(userAccontCfg.userGroup);
                    break;

                case USER_ACCOUNT_CFG_PASSWORD:
                    PRINT_STRING(userAccontCfg.password);
                    break;

                case (USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START) ... (USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_END):
                    PRINT_INT(userAccontCfg.userPrivilege[fieldLoop - USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START].privilegeGroup);
                    break;

                case USER_ACCOUNT_CFG_USERSTATUS:
                    PRINT_INT(userAccontCfg.userStatus);
                    break;

                case USER_ACCOUNT_CFG_MULTILOGIN:
                    PRINT_INT(userAccontCfg.multiLogin);
                    break;

                case USER_ACCOUNT_CFG_LOGINSESSION_LIMIT_DURATION:
                    PRINT_INT(userAccontCfg.loginSessionDuration);
                    break;

                case USER_ACCOUNT_CFG_SYNC_WITH_NET_DEVICES:
                    PRINT_INT(userAccontCfg.syncNetDev);
                    break;

                case USER_ACCOUNT_PREFERRED_LANGUAGE:
                    PRINT_STRING(userAccontCfg.preferredLanguage);
                    break;

                case USER_ACCOUNT_CFG_ALLOW_PUSH_NOTIFICATION:
                    PRINT_INT(userAccontCfg.managePushNotificationRights);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setUserAccountCfg(CHARPTR *reqStr)
{
	USER_ACCOUNT_CONFIG_t 	userAccountCfg;
    BOOL					writeStatus = SUCCESS;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;
	UINT64					indexId;
	UINT64					fieldId;
	UINT64					fieldVal = 0;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_USER_ACCOUNT_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleUserAccountConfig(indexId, &userAccountCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case USER_ACCOUNT_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, userAccountCfg.username, sizeof(userAccountCfg.username));
                    break;

                case USER_ACCOUNT_CFG_USERGROUP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.userGroup = fieldVal;
                    break;

                case USER_ACCOUNT_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, userAccountCfg.password, sizeof(userAccountCfg.password));
                    break;

                case (USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START) ... (USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.userPrivilege[fieldId - USER_ACCOUNT_CFG_USER_PRIVILEGE_GROUP_START].privilegeGroup = fieldVal;
                    break;

                case USER_ACCOUNT_CFG_USERSTATUS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.userStatus = fieldVal;
                    break;

                case USER_ACCOUNT_CFG_MULTILOGIN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.multiLogin = fieldVal;
                    break;

                case USER_ACCOUNT_CFG_LOGINSESSION_LIMIT_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.loginSessionDuration = fieldVal;
                    break;

                case USER_ACCOUNT_CFG_SYNC_WITH_NET_DEVICES:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.syncNetDev = fieldVal;
                    break;

                case USER_ACCOUNT_PREFERRED_LANGUAGE:
                    writeStatus = ParseStr(reqStr, FSP, userAccountCfg.preferredLanguage, sizeof(userAccountCfg.preferredLanguage));
                    break;

                case USER_ACCOUNT_CFG_ALLOW_PUSH_NOTIFICATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    userAccountCfg.managePushNotificationRights = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleUserAccountConfig(indexId, &userAccountCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defUserAccountCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleUserAccountConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                    CAMERA SETTINGS                                          **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getCameraCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	UINT16				indexLoop;
	CAMERA_CONFIG_t 	cameraCfg;
	UINT16				outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleCameraConfig(indexLoop, &cameraCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case CAMERA_CFG_CAMERA:
                    PRINT_INT(cameraCfg.camera);
                    break;

                case CAMERA_CFG_NAME:
                    PRINT_STRING(cameraCfg.name);
                    break;

                case CAMERA_CFG_TYPE:
                    PRINT_INT(cameraCfg.type);
                    break;

                case CAMERA_CFG_LOG_MOTION_EVENTS:
                    PRINT_INT(cameraCfg.logMotionEvents);
                    break;

                case CAMERA_CFG_MOTION_REDETECTION_DELAY:
                    PRINT_INT(cameraCfg.motionReDetectionDelay);
                    break;

                case CAMERA_CFG_CAMERA_NAME_POS:
                    PRINT_INT(cameraCfg.cameraNamePos);
                    break;

                case CAMERA_CFG_STATUS_POS:
                    PRINT_INT(cameraCfg.statusPos);
                    break;

                case CAMERA_CFG_DATETIME_OVERLAY:
                    PRINT_INT(cameraCfg.dateTimeOverlay);
                    break;

                case CAMERA_CFG_DATETIME_POS:
                    PRINT_INT(cameraCfg.dateTimePos);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_STATUS:
                    PRINT_INT(cameraCfg.channelNameOverlay);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_0_NAME:
                    PRINT_STRING(cameraCfg.channelName[0]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_0_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[0]);
                    break;

                case CAMERA_CFG_MOBILE_NUM:
                    PRINT_STRING(cameraCfg.mobileNum);
                    break;

                case CAMERA_CFG_PRIVACY_MASK_STATUS:
                    PRINT_INT(cameraCfg.privacyMaskStaus);
                    break;

                case CAMERA_CFG_MOTION_STATUS:
                    PRINT_INT(cameraCfg.motionDetectionStatus);
                    break;

                case CAMERA_CFG_RECORDING_STREAM:
                    PRINT_INT(cameraCfg.recordingStream);
                    break;

                case (CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_START)...(CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_1_NAME:
                    PRINT_STRING(cameraCfg.channelName[1]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_1_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[1]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_2_NAME:
                    PRINT_STRING(cameraCfg.channelName[2]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_2_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[2]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_3_NAME:
                    PRINT_STRING(cameraCfg.channelName[3]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_3_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[3]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_4_NAME:
                    PRINT_STRING(cameraCfg.channelName[4]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_4_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[4]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_5_NAME:
                    PRINT_STRING(cameraCfg.channelName[5]);
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_5_POSITION:
                    PRINT_INT(cameraCfg.channelNamePos[5]);
                    break;

                case (CAMERA_CFG_DUMMY_FIELD)...(MAX_CAMERA_CFG_FIELD):
                    PRINT_INT(0);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen ;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setCameraCfg(CHARPTR *reqStr)
{
	CAMERA_CONFIG_t 	cameraCfg;
	BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId = 0;
	UINT64				fieldId = 0;
	UINT64				fieldVal = 0;
    CAMERA_BIT_MASK_t   copyToCamera;

    memset(&copyToCamera, 0, sizeof(copyToCamera));
	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_CAMERA_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleCameraConfig(indexId, &cameraCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case CAMERA_CFG_CAMERA:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.camera = fieldVal;
                    break;

                case CAMERA_CFG_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.name, sizeof(cameraCfg.name));
                    break;

                case CAMERA_CFG_TYPE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.type = fieldVal;
                    break;

                case CAMERA_CFG_LOG_MOTION_EVENTS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.logMotionEvents = fieldVal;
                    break;

                case CAMERA_CFG_MOTION_REDETECTION_DELAY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.motionReDetectionDelay = fieldVal;
                    break;

                case CAMERA_CFG_CAMERA_NAME_POS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.cameraNamePos = fieldVal;
                    break;

                case CAMERA_CFG_STATUS_POS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.statusPos = fieldVal;
                    break;

                case CAMERA_CFG_DATETIME_OVERLAY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.dateTimeOverlay = fieldVal;
                    break;

                case CAMERA_CFG_DATETIME_POS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.dateTimePos = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNameOverlay = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_0_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[0], sizeof(cameraCfg.channelName[0]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_0_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[0] = fieldVal;
                    break;

                case CAMERA_CFG_MOBILE_NUM:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.mobileNum, sizeof(cameraCfg.mobileNum));
                    break;

                case CAMERA_CFG_PRIVACY_MASK_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.privacyMaskStaus = fieldVal;
                    break;

                case CAMERA_CFG_MOTION_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.motionDetectionStatus = fieldVal;
                    break;

                case CAMERA_CFG_RECORDING_STREAM:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.recordingStream = fieldVal;
                    break;

                case (CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_START)...(CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCamera.bitMask[fieldId - CAMERA_CFG_MOTION_DETECTION_COPY_TO_CAMERA_START] = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_1_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[1], sizeof(cameraCfg.channelName[1]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_1_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[1] = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_2_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[2], sizeof(cameraCfg.channelName[2]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_2_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[2] = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_3_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[3], sizeof(cameraCfg.channelName[3]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_3_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[3] = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_4_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[4], sizeof(cameraCfg.channelName[4]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_4_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[4] = fieldVal;
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_5_NAME:
                    writeStatus = ParseStr(reqStr, FSP, cameraCfg.channelName[5], sizeof(cameraCfg.channelName[5]));
                    break;

                case CAMERA_CFG_TEXT_OVERLAY_5_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cameraCfg.channelNamePos[5] = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleCameraConfig(indexId, &cameraCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }

        /* Clear self camera mask bit */
        CLR_CAMERA_MASK_BIT(copyToCamera, indexId);

        /* If copy to camera mask provided */
        if (FALSE == IS_ALL_CAMERA_MASK_BIT_CLR(copyToCamera))
        {
            /* Copy config to camera */
            MotionDetectionCopyToCamera(indexId, &cameraCfg, copyToCamera);
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defCameraCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleCameraConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                    STREAM SETTINGS                                          **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getStreamCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	UINT16				indexLoop;
	STREAM_CONFIG_t 	streamCfg;
	UINT16				outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        ReadSingleStreamConfig(indexLoop, &streamCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case STREAM_CFG_MAIN_STREAM_VIDEO_ENCODING:
                    PRINT_STRING(streamCfg.videoEncoding);
                    break;

                case STREAM_CFG_MAIN_STREAM_RESOLUTION:
                    PRINT_STRING(streamCfg.resolution);
                    break;

                case STREAM_CFG_MAIN_STREAM_FRAMERATE:
                    PRINT_INT(streamCfg.framerate);
                    break;

                case STREAM_CFG_MAIN_STREAM_BITRATE_MODE:
                    PRINT_INT(streamCfg.bitrateMode);
                    break;

                case STREAM_CFG_MAIN_STREAM_BITRATE_VALUE:
                    PRINT_INT(streamCfg.bitrateValue);
                    break;

                case STREAM_CFG_MAIN_STREAM_QUALITY:
                    PRINT_INT(streamCfg.quality);
                    break;

                case STREAM_CFG_MAIN_STREAM_GOP:
                    PRINT_INT(streamCfg.gop);
                    break;

                case STREAM_CFG_MAIN_STREAM_ENABLE_AUDIO:
                    PRINT_INT(streamCfg.enableAudio);
                    break;

                case STREAM_CFG_SUB_STREAM_VIDEO_ENCODING:
                    PRINT_STRING(streamCfg.videoEncodingSub);
                    break;

                case STREAM_CFG_SUB_STREAM_RESOLUTION:
                    PRINT_STRING(streamCfg.resolutionSub);
                    break;

                case STREAM_CFG_SUB_STREAM_FRAMERATE:
                    PRINT_INT(streamCfg.framerateSub);
                    break;

                case STREAM_CFG_SUB_STREAM_BITRATE_MODE:
                    PRINT_INT(streamCfg.bitrateModeSub);
                    break;

                case STREAM_CFG_SUB_STREAM_BITRATE_VALUE:
                    PRINT_INT(streamCfg.bitrateValueSub);
                    break;

                case STREAM_CFG_SUB_STREAM_QUALITY:
                    PRINT_INT(streamCfg.qualitySub);
                    break;

                case STREAM_CFG_SUB_STREAM_GOP:
                    PRINT_INT(streamCfg.gopSub);
                    break;

                case STREAM_CFG_SUB_STREAM_ENABLE_AUDIO:
                    PRINT_INT(streamCfg.enableAudioSub);
                    break;

                case STREAM_CFG_MAIN_STREAM_PROFILE:
                    PRINT_INT(streamCfg.mainStreamProfile);
                    break;

                case STREAM_CFG_SUB_STREAM_PROFILE:
                    PRINT_INT(streamCfg.subStreamProfile);
                    break;

                case (STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_START)...(STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                case (STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_START)...(STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setStreamCfg(CHARPTR *reqStr)
{
	STREAM_CONFIG_t 	streamCfg;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId;
	UINT64				fieldId;
	UINT64				fieldVal = 0;
    CAMERA_BIT_MASK_t   copyToCam[MAX_STREAM];

    memset(copyToCam, 0, sizeof(copyToCam));
	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // Increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_STREAM_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleStreamConfig(indexId, &streamCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case STREAM_CFG_MAIN_STREAM_VIDEO_ENCODING:
                    writeStatus = ParseStr(reqStr, FSP, streamCfg.videoEncoding, sizeof(streamCfg.videoEncoding));
                    break;

                case STREAM_CFG_MAIN_STREAM_RESOLUTION:
                    writeStatus = ParseStr(reqStr, FSP, streamCfg.resolution, sizeof(streamCfg.resolution));
                    break;

                case STREAM_CFG_MAIN_STREAM_FRAMERATE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.framerate = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_BITRATE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.bitrateMode = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_BITRATE_VALUE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.bitrateValue = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_QUALITY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.quality = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_GOP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.gop = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_ENABLE_AUDIO:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.enableAudio = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_VIDEO_ENCODING:
                    writeStatus = ParseStr(reqStr, FSP, streamCfg.videoEncodingSub, sizeof(streamCfg.videoEncodingSub));
                    break;

                case STREAM_CFG_SUB_STREAM_RESOLUTION:
                    writeStatus = ParseStr(reqStr, FSP, streamCfg.resolutionSub, sizeof(streamCfg.resolutionSub));
                    break;

                case STREAM_CFG_SUB_STREAM_FRAMERATE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.framerateSub = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_BITRATE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.bitrateModeSub = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_BITRATE_VALUE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.bitrateValueSub = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_QUALITY:

                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.qualitySub = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_GOP:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.gopSub = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_ENABLE_AUDIO:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.enableAudioSub = fieldVal;
                    break;

                case STREAM_CFG_MAIN_STREAM_PROFILE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.mainStreamProfile = fieldVal;
                    break;

                case STREAM_CFG_SUB_STREAM_PROFILE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    streamCfg.subStreamProfile = fieldVal;
                    break;

                case (STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_START)...(STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCam[MAIN_STREAM].bitMask[fieldId - STREAM_CFG_MAIN_STREAM_COPY_TO_CAMERA_START] = fieldVal;
                    break;

                case (STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_START)...(STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCam[SUB_STREAM].bitMask[fieldId - STREAM_CFG_SUB_STREAM_COPY_TO_CAMERA_START] = fieldVal;
                break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleStreamConfig(indexId, &streamCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }

        /* Clear self camera mask bit for main stream and sub stream */
        CLR_CAMERA_MASK_BIT(copyToCam[MAIN_STREAM], indexId);
        CLR_CAMERA_MASK_BIT(copyToCam[SUB_STREAM], indexId);

        /* If copy to camera mask provided */
        if ((FALSE == IS_ALL_CAMERA_MASK_BIT_CLR(copyToCam[MAIN_STREAM])) || (FALSE == IS_ALL_CAMERA_MASK_BIT_CLR(copyToCam[SUB_STREAM])))
        {
            /* Copy config to camera */
            retVal = StreamParamCopyToCamera(indexId, &streamCfg, copyToCam);
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defStreamCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleStreamConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                               ALARM RECORD SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getAlarmRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	ALARM_RECORD_CONFIG_t	alarmRecordCfg;
	UINT16					outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleAlarmRecordConfig(indexLoop, &alarmRecordCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case ALARM_RECORD_CFG_PRE_RECORD_TIME:
                    PRINT_INT(alarmRecordCfg.preRecordTime);
                    break;

                case ALARM_RECORD_CFG_POST_RECORD_TIME:
                    PRINT_INT(alarmRecordCfg.postRecordTime);
                    break;

                case (ALARM_RECORD_CFG_COPY_TO_CAMERA_START) ... (ALARM_RECORD_CFG_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;

        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setAlarmRecordCfg(CHARPTR *reqStr)
{
	ALARM_RECORD_CONFIG_t	alarmRecordCfg;
    BOOL					writeStatus = SUCCESS;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;
	UINT64					indexId;
	UINT64					fieldId;
	UINT64					fieldVal = 0;
	UINT8					camId = 0;
    CAMERA_BIT_MASK_t		copyToCam;

    memset(&copyToCam, 0, sizeof(copyToCam));
	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // Increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_ALARM_RECORD_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleAlarmRecordConfig(indexId, &alarmRecordCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case ALARM_RECORD_CFG_PRE_RECORD_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    alarmRecordCfg.preRecordTime = fieldVal;
                    break;

                case ALARM_RECORD_CFG_POST_RECORD_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    alarmRecordCfg.postRecordTime = fieldVal;
                    break;

                case (ALARM_RECORD_CFG_COPY_TO_CAMERA_START)...(ALARM_RECORD_CFG_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCam.bitMask[fieldId - ALARM_RECORD_CFG_COPY_TO_CAMERA_START] = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleAlarmRecordConfig(camId, &alarmRecordCfg);
                if(retVal != CMD_SUCCESS)
                {
                    writeStatus = FAIL;
                    break;
                }
            }
        }

        if (writeStatus == FAIL)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defAlarmRecordCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleAlarmRecordConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                          PTZ PRESET POSITIONS SETTINGS                                      **/
/** ******************************************************************************************* **/
static NET_CMD_STATUS_e getPresetPositionCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16              fieldLoop;
    UINT16              indexLoop;
    PTZ_PRESET_CONFIG_t ptzPresetCfg;
    UINT16              outLen = 0;
    UINT16              camIndex;
    UINT16              presetIndex;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		getXYIndx(indexLoop, MAX_PRESET_POSITION, &camIndex, &presetIndex);
        ReadSinglePtzPresetConfig(camIndex, presetIndex, &ptzPresetCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case PRESET_POSITION_CFG_NAME:
                    PRINT_STRING(ptzPresetCfg.name);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;

        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setPresetPositionCfg(CHARPTR *reqStr)
{
    PTZ_PRESET_CONFIG_t ptzPresetCfg;
    BOOL                writeStatus = SUCCESS;
    NET_CMD_STATUS_e    retVal = CMD_SUCCESS;
    UINT64              indexId;
    UINT64              fieldId;
    UINT16              camIndex;
    UINT16              presetIndex;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // Increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_PRESET_POSITION_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        getXYIndx(indexId, MAX_PRESET_POSITION, &camIndex, &presetIndex);
        ReadSinglePtzPresetConfig(camIndex, presetIndex, &ptzPresetCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case PRESET_POSITION_CFG_NAME:
                    writeStatus = ParseStr(reqStr, FSP, ptzPresetCfg.name, sizeof(ptzPresetCfg.name));
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSinglePtzPresetConfig(camIndex, presetIndex, &ptzPresetCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defPresetPositionCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop, camIndex, presetIndex;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
		getXYIndx(indexLoop, MAX_PRESET_POSITION, &camIndex, &presetIndex);
        if (CMD_SUCCESS != DfltSinglePtzPresetConfig(camIndex, presetIndex))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                             SCHEDULE RECORD SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getRecordingScheduleCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16			  	 	 fieldLoop;
	UINT16					 indexLoop;
	SCHEDULE_RECORD_CONFIG_t shedRecdCfg;
	UINT16					 outLen = 0;
	NET_CMD_STATUS_e		 retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
		if(SUCCESS != ReadSingleScheduleRecordConfig(indexLoop, &shedRecdCfg))
		{
            EPRINT(NETWORK_MANAGER, "fail to read schedule record config: [idx=%d]",indexLoop);
            continue;
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SHED_RECDNG_ENABLE:
                    PRINT_INT(shedRecdCfg.scheduleRecording);
                    break;

                case (SHED_RECDNG_COPY_TO_CAMERA_START)...(SHED_RECDNG_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

			if(retVal != CMD_SUCCESS)
			{
				break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
            break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setRecordingScheduleCfg1(CHARPTR *reqStr)
{
	SCHEDULE_RECORD_CONFIG_t 	schedRecdCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
    UINT16 						idx;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8						camId = 0;
    CAMERA_BIT_MASK_t			copyToCam;

    memset(&copyToCam, 0, sizeof(copyToCam));
	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse string");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_ENABLE_SCHEDULE_RECORD_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idx = CLIENT_TO_OUR_INDEX(idxId);
		if(SUCCESS != ReadSingleScheduleRecordConfig(idx, &schedRecdCfg))
		{
            EPRINT(NETWORK_MANAGER, "fail to read single schedule record config: [idx=%d]",idx);
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse string val");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case SHED_RECDNG_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg.scheduleRecording = val;
                    break;

                case (SHED_RECDNG_COPY_TO_CAMERA_START)...(SHED_RECDNG_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    copyToCam.bitMask[fieldId - SHED_RECDNG_COPY_TO_CAMERA_START] = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleScheduleRecordConfig(camId, &schedRecdCfg);
                if(retVal != CMD_SUCCESS)
                {
                    break;
                }
            }
        }

		*reqStr = *reqStr + 1;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

	*reqStr = *reqStr + 1;
	return retVal;
}

static NET_CMD_STATUS_e defaultRecordingScheduleCfg1(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if(CMD_SUCCESS != DfltSingleScheduleRecordConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getRecordingScheduleCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					 fieldLoop;
	SCHEDULE_RECORD_CONFIG_t shedRecdCfg = { 0 };
	UINT16					 outLen = 0;
	UINT16 					 startIdx, temp, weekDaysIdx, camIdx;
	NET_CMD_STATUS_e		 retVal = CMD_SUCCESS;

	camIdx = getMaxCameraForCurrentVariant();
	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		getXYIndx(startIdx, MAX_WEEK_DAYS, &temp, &weekDaysIdx);
		if(camIdx != temp)
		{
			camIdx = temp;
			if(SUCCESS != ReadSingleScheduleRecordConfig(camIdx, &shedRecdCfg))
			{
                EPRINT(NETWORK_MANAGER, "fail to read schedule record config: [camera=%d]", camIdx);
				continue;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case RECD_ENTIRE_DAY:
                    PRINT_INT(shedRecdCfg.dailyRecord[weekDaysIdx].recordEntireDay);
                    break;

                case PERIOD0_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[0].startTime);
                    break;

                case PERIOD0_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[0].endTime);
                    break;

                case PERIOD1_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[1].startTime);
                    break;

                case PERIOD1_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[1].endTime);
                    break;

                case PERIOD2_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[2].startTime);
                    break;

                case PERIOD2_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[2].endTime);
                    break;

                case PERIOD3_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[3].startTime);
                    break;

                case PERIOD3_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[3].endTime);
                    break;

                case PERIOD4_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[4].startTime);
                    break;

                case PERIOD4_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[4].endTime);
                    break;

                case PERIOD5_START_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[5].startTime);
                    break;

                case PERIOD5_END_TIME:
                    PRINT_TIME(shedRecdCfg.dailyRecord[weekDaysIdx].period[5].endTime);
                    break;

                case (PERIOD_COPY_TO_CAMERA_START)...(PERIOD_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setRecordingScheduleCfg2(CHARPTR *reqStr)
{
	SCHEDULE_RECORD_CONFIG_t 	schedRecdCfg[MAX_CAMERA];
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	UINT16 						camIdx, tmpIdx, weekDaysIdx;
	BOOL 						writeStatus = FAIL;
    CAMERA_BIT_MASK_t           copyToCam;
	UINT8						camId = 0;

    memset(&copyToCam, 0, sizeof(copyToCam));
	camIdx = (UINT16)getMaxCameraForCurrentVariant();
	do
	{
		//Check whether first elemnt is SOI or not and increment address to
		//retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse string");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SCHEDULE_RECORD_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		getXYIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_WEEK_DAYS, &tmpIdx, &weekDaysIdx);
		if(camIdx != tmpIdx)
		{
			camIdx = tmpIdx;
			ReadSingleScheduleRecordConfig(camIdx, &schedRecdCfg[camIdx]);
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
                EPRINT(NETWORK_MANAGER, "fail to parse string val");
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case RECD_ENTIRE_DAY:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].recordEntireDay = val;
                    break;

                case PERIOD0_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[0].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[0].startTime.minute = val % 100;
                    break;

                case PERIOD0_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[0].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[0].endTime.minute = val % 100;
                    break;

                case PERIOD1_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[1].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[1].startTime.minute = val % 100;
                    break;

                case PERIOD1_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[1].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[1].endTime.minute = val % 100;
                    break;

                case PERIOD2_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[2].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[2].startTime.minute = val % 100;
                    break;

                case PERIOD2_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[2].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[2].endTime.minute = val % 100;
                    break;

                case PERIOD3_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[3].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[3].startTime.minute = val % 100;
                    break;

                case PERIOD3_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[3].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[3].endTime.minute = val % 100;
                    break;

                case PERIOD4_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[4].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[4].startTime.minute = val % 100;
                    break;

                case PERIOD4_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[4].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[4].endTime.minute = val % 100;
                    break;

                case PERIOD5_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[5].startTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[5].startTime.minute = val % 100;
                    break;

                case PERIOD5_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[5].endTime.hour = val / 100;
                    schedRecdCfg[camIdx].dailyRecord[weekDaysIdx].period[5].endTime.minute = val % 100;
                    break;

                case (PERIOD_COPY_TO_CAMERA_START)...(PERIOD_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    copyToCam.bitMask[fieldId - PERIOD_COPY_TO_CAMERA_START] = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

		*reqStr = *reqStr + 1;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

    *reqStr = *reqStr + 1;
	if(writeStatus == SUCCESS)
    {
        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleScheduleRecordConfig(camId, &schedRecdCfg[camIdx]);
                if(retVal != CMD_SUCCESS)
                {
                    break;
                }
            }
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e defaultRecordingScheduleCfg2(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16  indexLoop, camIdx, weekDaysIdx;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
		getXYIndx(indexLoop, MAX_WEEK_DAYS, &camIdx, &weekDaysIdx);
        if(CMD_SUCCESS != DfltSingleScheduleRecordConfig(camIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                               PRESET TOUR SETTINGS                                          **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getPresetTourCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	PRESET_TOUR_CONFIG_t 	presetTourCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e		status = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSinglePresetTourConfig(indexLoop, &presetTourCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case MANUAL_TOUR_OVER_RIDE:
                    PRINT_INT(presetTourCfg.manualTourOverride);
                    break;

                case MANUAL_TOUR:
                    PRINT_INT(presetTourCfg.manualTour);
                    break;

                case ACTIVE_TOUR_OVER_RIDE:
                    PRINT_INT(presetTourCfg.activeTourOverride);
                    break;

                default:
                    status = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(status != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(status != CMD_SUCCESS)
		{
			break;
		}
	}

	return status;
}

static NET_CMD_STATUS_e setPresetTourCfg1(CHARPTR *reqStr)
{
	PRESET_TOUR_CONFIG_t 	 	presetTourCfg;
	UINT64 						fieldId = 0;
	UINT64 						idxId;
	UINT64 						val = 0;
    UINT16 						idx;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;

	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse string");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_MANUAL_PRESET_TOUR_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idx = CLIENT_TO_OUR_INDEX(idxId);
		ReadSinglePresetTourConfig(idx, &presetTourCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
				retVal = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "fail to parse string");
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case MANUAL_TOUR_OVER_RIDE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg.manualTourOverride = val;
                    break;

                case MANUAL_TOUR:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg.manualTour = val;
                    break;

                case ACTIVE_TOUR_OVER_RIDE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg.activeTourOverride = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
            }

			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSinglePresetTourConfig(idx, &presetTourCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		*reqStr = *reqStr + 1;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

	*reqStr = *reqStr + 1;
	return retVal;
}

static NET_CMD_STATUS_e defaultPresetTourCfg1(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSinglePresetTourConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getPresetTourCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					 fieldLoop;
	PRESET_TOUR_CONFIG_t 	 presetTourCfg = { 0 };
	UINT16					 outLen = 0;
	UINT16 					 startIdx, temp;
	UINT16 					 tourIdx;
	UINT16 					 camIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;

	camIdx = getMaxCameraForCurrentVariant();
	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		getXYIndx(startIdx, MAX_TOUR_NUMBER, &temp, &tourIdx);
		if(camIdx != temp)
		{
			camIdx = temp;
			if(SUCCESS != ReadSinglePresetTourConfig(camIdx, &presetTourCfg))
			{
                EPRINT(NETWORK_MANAGER, "fail to read single preset tour: [camera=%d]", camIdx);
				continue;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case TOUR_NAME:
                    PRINT_STRING(presetTourCfg.tour[tourIdx].name);
                    break;

                case TOUR_PATTERN:
                    PRINT_INT(presetTourCfg.tour[tourIdx].tourPattern);
                    break;

                case PAUSE_BETWEEN_TOUR:
                    PRINT_INT(presetTourCfg.tour[tourIdx].pauseBetweenTour);
                    break;

                case TOUR_PTZ0_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[0].presetPosition);
                    break;

                case TOUR_PTZ0_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[0].viewTime);
                    break;

                case TOUR_PTZ1_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[1].presetPosition);
                    break;

                case TOUR_PTZ1_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[1].viewTime);
                    break;

                case TOUR_PTZ2_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[2].presetPosition);
                    break;

                case TOUR_PTZ2_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[2].viewTime);
                    break;

                case TOUR_PTZ3_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[3].presetPosition);
                    break;

                case TOUR_PTZ3_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[3].viewTime);
                    break;

                case TOUR_PTZ4_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[4].presetPosition);
                    break;

                case TOUR_PTZ4_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[4].viewTime);
                    break;

                case TOUR_PTZ5_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[5].presetPosition);
                    break;

                case TOUR_PTZ5_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[5].viewTime);
                    break;

                case TOUR_PTZ6_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[6].presetPosition);
                    break;

                case TOUR_PTZ6_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[6].viewTime);
                    break;

                case TOUR_PTZ7_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[7].presetPosition);
                    break;

                case TOUR_PTZ7_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[7].viewTime);
                    break;

                case TOUR_PTZ8_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[8].presetPosition);
                    break;

                case TOUR_PTZ8_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[8].viewTime);
                    break;

                case TOUR_PTZ9_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[9].presetPosition);
                    break;

                case TOUR_PTZ9_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[9].viewTime);
                    break;

                case TOUR_PTZ10_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[10].presetPosition);
                    break;

                case TOUR_PTZ10_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[10].viewTime);
                    break;

                case TOUR_PTZ11_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[11].presetPosition);
                    break;

                case TOUR_PTZ11_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[11].viewTime);
                    break;

                case TOUR_PTZ12_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[12].presetPosition);
                    break;

                case TOUR_PTZ12_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[12].viewTime);
                    break;

                case TOUR_PTZ13_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[13].presetPosition);
                    break;

                case TOUR_PTZ13_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[13].viewTime);
                    break;

                case TOUR_PTZ14_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[14].presetPosition);
                    break;

                case TOUR_PTZ14_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[14].viewTime);
                    break;

                case TOUR_PTZ15_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[15].presetPosition);
                    break;

                case TOUR_PTZ15_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[15].viewTime);
                    break;

                case TOUR_PTZ16_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[16].presetPosition);
                    break;

                case TOUR_PTZ16_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[16].viewTime);
                    break;

                case TOUR_PTZ17_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[17].presetPosition);
                    break;

                case TOUR_PTZ17_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[17].viewTime);
                    break;

                case TOUR_PTZ18_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[18].presetPosition);
                    break;

                case TOUR_PTZ18_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[18].viewTime);
                    break;

                case TOUR_PTZ19_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[19].presetPosition);
                    break;

                case TOUR_PTZ19_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[19].viewTime);
                    break;

                case TOUR_PTZ20_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[20].presetPosition);
                    break;

                case TOUR_PTZ20_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[20].viewTime);
                    break;

                case TOUR_PTZ21_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[21].presetPosition);
                    break;

                case TOUR_PTZ21_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[21].viewTime);
                    break;

                case TOUR_PTZ22_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[22].presetPosition);
                    break;

                case TOUR_PTZ22_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[22].viewTime);
                    break;

                case TOUR_PTZ23_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[23].presetPosition);
                    break;

                case TOUR_PTZ23_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[23].viewTime);
                    break;

                case TOUR_PTZ24_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[24].presetPosition);
                    break;

                case TOUR_PTZ24_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[24].viewTime);
                    break;

                case TOUR_PTZ25_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[25].presetPosition);
                    break;

                case TOUR_PTZ25_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[25].viewTime);
                    break;

                case TOUR_PTZ26_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[26].presetPosition);
                    break;

                case TOUR_PTZ26_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[26].viewTime);
                    break;

                case TOUR_PTZ27_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[27].presetPosition);
                    break;

                case TOUR_PTZ27_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[27].viewTime);
                    break;

                case TOUR_PTZ28_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[28].presetPosition);
                    break;

                case TOUR_PTZ28_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[28].viewTime);
                    break;

                case TOUR_PTZ29_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[29].presetPosition);
                    break;

                case TOUR_PTZ29_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[29].viewTime);
                    break;

                case TOUR_PTZ30_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[30].presetPosition);
                    break;

                case TOUR_PTZ30_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[30].viewTime);
                    break;

                case TOUR_PTZ31_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[31].presetPosition);
                    break;

                case TOUR_PTZ31_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[31].viewTime);
                    break;

                case TOUR_PTZ32_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[32].presetPosition);
                    break;

                case TOUR_PTZ32_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[32].viewTime);
                    break;

                case TOUR_PTZ33_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[33].presetPosition);
                    break;

                case TOUR_PTZ33_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[33].viewTime);
                    break;

                case TOUR_PTZ34_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[34].presetPosition);
                    break;

                case TOUR_PTZ34_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[34].viewTime);
                    break;

                case TOUR_PTZ35_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[35].presetPosition);
                    break;

                case TOUR_PTZ35_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[35].viewTime);
                    break;

                case TOUR_PTZ36_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[36].presetPosition);
                    break;

                case TOUR_PTZ36_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[36].viewTime);
                    break;

                case TOUR_PTZ37_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[37].presetPosition);
                    break;

                case TOUR_PTZ37_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[37].viewTime);
                    break;

                case TOUR_PTZ38_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[38].presetPosition);
                    break;

                case TOUR_PTZ38_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[38].viewTime);
                    break;

                case TOUR_PTZ39_PRESET_POSITION:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[39].presetPosition);
                    break;

                case TOUR_PTZ39_VIEW_TIME:
                    PRINT_INT(presetTourCfg.tour[tourIdx].ptz[39].viewTime);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setPresetTourCfg2(CHARPTR *reqStr)
{
	PRESET_TOUR_CONFIG_t 		presetTourCfg[MAX_CAMERA];
	UINT8 						availableChannel[MAX_CAMERA];
	UINT8						channelCnt;
	UINT64 						fieldId = 0;
	UINT64 						idxId;
	UINT64 						val;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16						camIdx;
	UINT16 						tmpIndex;
	UINT16 						tourIdx, tmp;
	UINT16						idx;

	memset(availableChannel, MAX_CAMERA, sizeof(availableChannel));

	channelCnt = 0;

	camIdx = getMaxCameraForCurrentVariant();
    //Assign previous index with invalid value
	do
	{

		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse string");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_AUTO_PRESET_TOUR_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idx = CLIENT_TO_OUR_INDEX(idxId);
		getXYIndx(idx, MAX_TOUR_NUMBER, &tmpIndex, &tourIdx);

		//read configuration when camera index changes
		if(tmpIndex != camIdx)
		{
			camIdx = tmpIndex;
			ReadSinglePresetTourConfig(camIdx, &presetTourCfg[camIdx]);

			//save channel number
			availableChannel[channelCnt] = camIdx;
			channelCnt++;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
				retVal = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = fieldId - 1;
			switch(tmp)
			{
                case TOUR_NAME:
                    writeStatus = ParseStr(reqStr, FSP, presetTourCfg[camIdx].tour[tourIdx].name, sizeof(presetTourCfg[camIdx].tour[tourIdx].name));
                    break;

                case TOUR_PATTERN:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].tourPattern = val;
                    break;

                case PAUSE_BETWEEN_TOUR:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].pauseBetweenTour = val;
                    break;

                case TOUR_PTZ0_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[0].presetPosition = val;
                    break;

                case TOUR_PTZ0_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[0].viewTime = val;
                    break;

                case TOUR_PTZ1_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[1].presetPosition = val;
                    break;

                case TOUR_PTZ1_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[1].viewTime = val;
                    break;

                case TOUR_PTZ2_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[2].presetPosition = val;
                    break;

                case TOUR_PTZ2_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[2].viewTime = val;
                    break;

                case TOUR_PTZ3_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[3].presetPosition = val;
                    break;

                case TOUR_PTZ3_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[3].viewTime = val;
                    break;

                case TOUR_PTZ4_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[4].presetPosition = val;
                    break;

                case TOUR_PTZ4_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[4].viewTime = val;
                    break;

                case TOUR_PTZ5_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[5].presetPosition = val;
                    break;

                case TOUR_PTZ5_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[5].viewTime = val;
                    break;

                case TOUR_PTZ6_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[6].presetPosition = val;
                    break;

                case TOUR_PTZ6_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[6].viewTime = val;
                    break;

                case TOUR_PTZ7_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[7].presetPosition = val;
                    break;

                case TOUR_PTZ7_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[7].viewTime = val;
                    break;

                case TOUR_PTZ8_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[8].presetPosition = val;
                    break;

                case TOUR_PTZ8_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[8].viewTime = val;
                    break;

                case TOUR_PTZ9_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[9].presetPosition = val;
                    break;

                case TOUR_PTZ9_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[9].viewTime = val;
                    break;

                case TOUR_PTZ10_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[10].presetPosition = val;
                    break;

                case TOUR_PTZ10_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[10].viewTime = val;
                    break;

                case TOUR_PTZ11_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[11].presetPosition = val;
                    break;

                case TOUR_PTZ11_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[11].viewTime = val;
                    break;

                case TOUR_PTZ12_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[12].presetPosition = val;
                    break;

                case TOUR_PTZ12_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[12].viewTime = val;
                    break;

                case TOUR_PTZ13_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[13].presetPosition = val;
                    break;

                case TOUR_PTZ13_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[13].viewTime = val;
                    break;

                case TOUR_PTZ14_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[14].presetPosition = val;
                    break;

                case TOUR_PTZ14_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[14].viewTime = val;
                    break;

                case TOUR_PTZ15_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[15].presetPosition = val;
                    break;

                case TOUR_PTZ15_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[15].viewTime = val;
                    break;

                case TOUR_PTZ16_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[16].presetPosition = val;
                    break;

                case TOUR_PTZ16_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[16].viewTime = val;
                    break;

                case TOUR_PTZ17_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[17].presetPosition = val;
                    break;

                case TOUR_PTZ17_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[17].viewTime = val;
                    break;

                case TOUR_PTZ18_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[18].presetPosition = val;
                    break;

                case TOUR_PTZ18_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[18].viewTime = val;
                    break;

                case TOUR_PTZ19_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[19].presetPosition = val;
                    break;

                case TOUR_PTZ19_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[19].viewTime = val;
                    break;

                case TOUR_PTZ20_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[20].presetPosition = val;
                    break;

                case TOUR_PTZ20_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[20].viewTime = val;
                    break;

                case TOUR_PTZ21_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[21].presetPosition = val;
                    break;

                case TOUR_PTZ21_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[21].viewTime = val;
                    break;

                case TOUR_PTZ22_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[22].presetPosition = val;
                    break;

                case TOUR_PTZ22_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[22].viewTime = val;
                    break;

                case TOUR_PTZ23_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[23].presetPosition = val;
                    break;

                case TOUR_PTZ23_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[23].viewTime = val;
                    break;

                case TOUR_PTZ24_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[24].presetPosition = val;
                    break;

                case TOUR_PTZ24_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[24].viewTime = val;
                    break;

                case TOUR_PTZ25_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[25].presetPosition = val;
                    break;

                case TOUR_PTZ25_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[25].viewTime = val;
                    break;

                case TOUR_PTZ26_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[26].presetPosition = val;
                    break;

                case TOUR_PTZ26_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[26].viewTime = val;
                    break;

                case TOUR_PTZ27_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[27].presetPosition = val;
                    break;

                case TOUR_PTZ27_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[27].viewTime = val;
                    break;

                case TOUR_PTZ28_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[28].presetPosition = val;
                    break;

                case TOUR_PTZ28_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[28].viewTime = val;
                    break;

                case TOUR_PTZ29_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[29].presetPosition = val;
                    break;

                case TOUR_PTZ29_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[29].viewTime = val;
                    break;

                case TOUR_PTZ30_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[30].presetPosition = val;
                    break;

                case TOUR_PTZ30_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[30].viewTime = val;
                    break;

                case TOUR_PTZ31_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[31].presetPosition = val;
                    break;

                case TOUR_PTZ31_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[31].viewTime = val;
                    break;

                case TOUR_PTZ32_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[32].presetPosition = val;
                    break;

                case TOUR_PTZ32_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[32].viewTime = val;
                    break;

                case TOUR_PTZ33_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[33].presetPosition = val;
                    break;

                case TOUR_PTZ33_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[33].viewTime = val;
                    break;

                case TOUR_PTZ34_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[34].presetPosition = val;
                    break;

                case TOUR_PTZ34_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[34].viewTime = val;
                    break;

                case TOUR_PTZ35_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[35].presetPosition = val;
                    break;

                case TOUR_PTZ35_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[35].viewTime = val;
                    break;

                case TOUR_PTZ36_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[36].presetPosition = val;
                    break;

                case TOUR_PTZ36_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[36].viewTime = val;
                    break;

                case TOUR_PTZ37_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[37].presetPosition = val;
                    break;

                case TOUR_PTZ37_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[37].viewTime = val;
                    break;

                case TOUR_PTZ38_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[38].presetPosition = val;
                    break;

                case TOUR_PTZ38_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[38].viewTime = val;
                    break;

                case TOUR_PTZ39_PRESET_POSITION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[39].presetPosition = val;
                    break;

                case TOUR_PTZ39_VIEW_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    presetTourCfg[camIdx].tour[tourIdx].ptz[39].viewTime = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus == FAIL)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		*reqStr = *reqStr + 1;

	}while(**reqStr != EOT);

	(*reqStr)++;

	if(writeStatus == SUCCESS)
	{
		while(channelCnt > 0)
		{
            channelCnt--;
            retVal = WriteSinglePresetTourConfig(availableChannel[channelCnt], &presetTourCfg[availableChannel[channelCnt]]);
            if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e defaultPresetTourCfg2(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId, camIdx, tourIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYIndx(idxId, MAX_TOUR_NUMBER, &camIdx, &tourIdx);
        if(CMD_SUCCESS != DfltSinglePresetTourConfig(camIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                           PRESET TOUR SCHEDULE SETTINGS                                     **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getPresetTourSchedCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	TOUR_SCHEDULE_CONFIG_t 	tourSchedCfg;
	UINT16					outLen = 0;
	UINT16 					weekDaysIdx;
	UINT16 					camIdx, tmp;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;

    memset(&tourSchedCfg, 0, sizeof(tourSchedCfg));
	camIdx = tmp = getMaxCameraForCurrentVariant();
	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		getXYIndx(indexLoop, MAX_WEEK_DAYS, &tmp, &weekDaysIdx);
		if(tmp != camIdx)
		{
			camIdx = tmp;
			if(SUCCESS != ReadSingleTourScheduleConfig(camIdx, &tourSchedCfg))
			{
                EPRINT(NETWORK_MANAGER," Failed to read Schdule Record Config CamIdx:%d",camIdx);
				continue;
			}
		}

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case PRESET_TOUR_ENTIRE_DAY:
                    PRINT_INT(tourSchedCfg.tour[weekDaysIdx].entireDay);
                    break;

                case PRESET_TOUR_NUM:
                    PRINT_INT(tourSchedCfg.tour[weekDaysIdx].presetTour);
                    break;

                case PRESET_TOUR_SCHED0_START_TIME:
                    PRINT_TIME(tourSchedCfg.tour[weekDaysIdx].schedule[0].period.startTime);
                    break;

                case PRESET_TOUR_SCHED0_END_TIME:
                    PRINT_TIME(tourSchedCfg.tour[weekDaysIdx].schedule[0].period.endTime);
                    break;

                case PRESET_TOUR_SCHED0_TOUR_NUM:
                    PRINT_INT(tourSchedCfg.tour[weekDaysIdx].schedule[0].presetTour);
                    break;

                case PRESET_TOUR_SCHED1_START_TIME:
                    PRINT_TIME(tourSchedCfg.tour[weekDaysIdx].schedule[1].period.startTime);
                    break;

                case PRESET_TOUR_SCHED1_END_TIME:
                    PRINT_TIME(tourSchedCfg.tour[weekDaysIdx].schedule[1].period.endTime);
                    break;

                case PRESET_TOUR_SCHED1_TOUR_NUM:
                    PRINT_INT(tourSchedCfg.tour[weekDaysIdx].schedule[1].presetTour);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setPresetTourSchedCfg(CHARPTR *reqStr)
{
	TOUR_SCHEDULE_CONFIG_t 		tourSchedCfg[MAX_CAMERA];
	UINT8 						availableChannel[MAX_CAMERA];
    UINT8						channelCnt = 0;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16						camIdx, weekDaysIdx;
	UINT8 						tmp;
	UINT16 						prevIndex, maxPresetTourIdx;

	maxPresetTourIdx = GET_MAX_INDEX(getMaxCameraForCurrentVariant(), MAX_WEEK_DAYS);
	memset(availableChannel, MAX_CAMERA, sizeof(availableChannel));

    //Assign previous index with invalid value
	prevIndex = maxPresetTourIdx;
	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}
		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_PRESET_TOUR_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		//Retrieve camera index
		getXYIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_WEEK_DAYS, &camIdx, &weekDaysIdx);

		//read configuration when camera index changes
		if(prevIndex != camIdx)
		{
			ReadSingleTourScheduleConfig(camIdx, &tourSchedCfg[camIdx]);
			prevIndex = camIdx;
			availableChannel[channelCnt] = camIdx;
			channelCnt++;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case PRESET_TOUR_ENTIRE_DAY:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].entireDay = val;
                    break;

                case PRESET_TOUR_NUM:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].presetTour = val;
                    break;

                case PRESET_TOUR_SCHED0_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[0].period.startTime.minute = val % 100;
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[0].period.startTime.hour  = val / 100;
                    break;

                case PRESET_TOUR_SCHED0_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[0].period.endTime.minute = val % 100;
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[0].period.endTime.hour  = val / 100;
                    break;

                case PRESET_TOUR_SCHED0_TOUR_NUM:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[0].presetTour = val;
                    break;

                case PRESET_TOUR_SCHED1_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[1].period.startTime.minute = val % 100;
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[1].period.startTime.hour  = val / 100;
                    break;

                case PRESET_TOUR_SCHED1_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[1].period.endTime.minute = val % 100;
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[1].period.endTime.hour  = val / 100;
                    break;

                case PRESET_TOUR_SCHED1_TOUR_NUM:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    tourSchedCfg[camIdx].tour[weekDaysIdx].schedule[1].presetTour = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus == FAIL)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		if(writeStatus == FAIL)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;

	if(writeStatus == SUCCESS)
	{
		for(channelCnt = 0 ; availableChannel[channelCnt] < getMaxCameraForCurrentVariant(); channelCnt++)
		{
            retVal = WriteSingleTourScheduleConfig(availableChannel[channelCnt], &tourSchedCfg[availableChannel[channelCnt]]);
            if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e defaultPresetTourSchedCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId, camIdx, weekDaysIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYIndx(idxId, MAX_WEEK_DAYS, &camIdx, &weekDaysIdx);
        if(CMD_SUCCESS != DfltSingleTourScheduleConfig(camIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                            SYSTEM SENSOR INPUT SETTINGS                                     **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSensorCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	SENSOR_CONFIG_t 		sensorCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleSensorConfig(indexLoop, &sensorCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SENSOR_DETECT:
                    PRINT_INT(sensorCfg.sensorDetect);
                    break;

                case SENSOR_NAME:
                    PRINT_STRING(sensorCfg.name);
                    break;

                case SENSOR_MODE:
                    PRINT_INT(sensorCfg.normalMode);
                    break;

                case SENSOR_DEBOUNCE_TIME:
                    PRINT_INT(sensorCfg.debounceTime);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setSensorCnfg(CHARPTR *reqStr)
{
	SENSOR_CONFIG_t 			sensorCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	UINT16 						idx, tmp;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
    BOOL						writeStatus = FAIL;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SYS_SENOR_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idx = CLIENT_TO_OUR_INDEX(idxId);
		ReadSingleSensorConfig(idx, &sensorCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case SENSOR_DETECT:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sensorCfg.sensorDetect = val;
                    break;

                case SENSOR_NAME:
                    writeStatus = ParseStr(reqStr, FSP, sensorCfg.name, sizeof(sensorCfg.name));
                    break;

                case SENSOR_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sensorCfg.normalMode = val;
                    break;

                case SENSOR_DEBOUNCE_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sensorCfg.debounceTime = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if(writeStatus == FAIL)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        retVal = WriteSingleSensorConfig(idx, &sensorCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		// increment for EOI
		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultSensorCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleSensorConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                            SYSTEM ALARM OUTPUT SETTINGS                                     **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSystemAlmCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	ALARM_CONFIG_t	 		sysAlmCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleAlarmConfig(indexLoop, &sysAlmCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SYS_ALM_OUTPUT:
                    PRINT_INT(sysAlmCfg.alarmOutput);
                    break;

                case SYS_ALM_NAME:
                    PRINT_STRING(sysAlmCfg.name);
                    break;

                case SYS_ALM_MODE:
                    PRINT_INT(sysAlmCfg.activeMode);
                    break;

                case SYS_ALM_PULSE_PERIOD:
                    PRINT_INT(sysAlmCfg.pulsePeriod);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setSysAlmCfg(CHARPTR *reqStr)
{
	ALARM_CONFIG_t 				sysAlmCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT16 						index, field;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SYS_ALARM_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		index = (UINT8)(CLIENT_TO_OUR_INDEX(idxId));
		ReadSingleAlarmConfig(index, &sysAlmCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

			field = CLIENT_TO_OUR_INDEX(fieldId);
			switch(field)
			{
                case SYS_ALM_OUTPUT:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sysAlmCfg.alarmOutput = val;
                    break;

                case SYS_ALM_NAME:
                    writeStatus = ParseStr(reqStr, FSP, sysAlmCfg.name, sizeof(sysAlmCfg.name));
                    break;

                case SYS_ALM_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sysAlmCfg.activeMode = val;
                    break;

                case SYS_ALM_PULSE_PERIOD:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    sysAlmCfg.pulsePeriod = val;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        retVal = WriteSingleAlarmConfig(index, &sysAlmCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultSysAlmCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleAlarmConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                               UPLOAD IMAGE SETTINGS                                         **/
/** ******************************************************************************************* **/
static NET_CMD_STATUS_e getImgUpldCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	IMAGE_UPLOAD_CONFIG_t	imgUpldCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleImageUploadConfig(indexLoop, &imgUpldCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case IMG_UPLD_RESOLUTION:
                    PRINT_STRING(imgUpldCfg.resolution);
                    break;

                case IMG_UPLD_LOCATION:
                    PRINT_INT(imgUpldCfg.uploadLocation);
                    break;

                case IMG_UPLD_EMAIL_ADDR:
                    PRINT_STRING(imgUpldCfg.uploadToEmail.emailAddress);
                    break;

                case IMG_UPLD_EMAIL_SUBJECT:
                    PRINT_STRING(imgUpldCfg.uploadToEmail.subject);
                    break;

                case IMG_UPLD_EMAIL_MESSAGE:
                    PRINT_STRING(imgUpldCfg.uploadToEmail.message);
                    break;

                case IMG_UPLD_RATE:
                    PRINT_INT(imgUpldCfg.uploadImageRate);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
    }

	return retVal;
}

static NET_CMD_STATUS_e setImgUpldCfg(CHARPTR *reqStr)
{
	IMAGE_UPLOAD_CONFIG_t 		imgUpldCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT8 						index;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8 						tmp;

	do
	{
		if((reqStr == NULL) || (*reqStr == NULL))
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_UPLOAD_IMAGE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		index = (UINT8)(CLIENT_TO_OUR_INDEX(idxId));
		ReadSingleImageUploadConfig(index, &imgUpldCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case IMG_UPLD_RESOLUTION:
                    writeStatus = ParseStr(reqStr, FSP, imgUpldCfg.resolution, sizeof(imgUpldCfg.resolution));
                    break;

                case IMG_UPLD_LOCATION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    imgUpldCfg.uploadLocation = val;
                    break;

                case IMG_UPLD_EMAIL_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, imgUpldCfg.uploadToEmail.emailAddress, sizeof(imgUpldCfg.uploadToEmail.emailAddress));
                    break;

                case IMG_UPLD_EMAIL_SUBJECT:
                    writeStatus = ParseStr(reqStr, FSP, imgUpldCfg.uploadToEmail.subject, sizeof(imgUpldCfg.uploadToEmail.subject));
                    break;

                case IMG_UPLD_EMAIL_MESSAGE:
                    writeStatus = ParseStr(reqStr, FSP, imgUpldCfg.uploadToEmail.message, sizeof(imgUpldCfg.uploadToEmail.message));
                    break;

                case IMG_UPLD_RATE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    imgUpldCfg.uploadImageRate = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSingleImageUploadConfig(index, &imgUpldCfg);
        if(retVal != CMD_SUCCESS)
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

    //If reqStr is not NULL then increment
    if ((reqStr != NULL) && (*reqStr != NULL))
    {
        (*reqStr)++;
    }

	return retVal;
}

static NET_CMD_STATUS_e defaultImgUpldCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleImageUploadConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                   STORAGE SETTINGS                                          **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getStorageConfig(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	STORAGE_CONFIG_t		storageCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadStorageConfig(&storageCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case STORAGE_HDD_FULL_ACTION_MODE:
                    PRINT_INT(storageCfg.hddFull.actionMode);
                    break;

                case STORAGE_HDD_FULL_PERCENTAGE_CLEAN:
                    PRINT_INT(storageCfg.hddFull.percentCleanup);
                    break;

                case STORAGE_RECORD_RETENTATION_STATUS:
                    PRINT_INT(storageCfg.recordRetentionStatus);
                    break;

                case STORAGE_RECORD_RETENTATION_TYPE:
                    PRINT_INT(storageCfg.recordRetentionType);
                    break;

                case STORAGE_DRIVE_WISE_RECORD_CLEANUP_DAYS:
                    PRINT_INT(storageCfg.driveWiseRecordCleanupByDays);
                    break;

                case (STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START) ... (STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_END):
                    PRINT_INT(storageCfg.cameraWiseRecordCleanupByDays[(fieldLoop - STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START)]);
                    break;

                case STORAGE_BACKUP_RETENTATION_STATUS:
                    PRINT_INT(storageCfg.backUpRetentionStatus);
                    break;

                case (STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START) ... (STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_END):
                    PRINT_INT(storageCfg.cameraWiseBackUpCleanupByDays[(fieldLoop - STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START)]);
                    break;

                case STORAGE_STRG_ALT_ALERT:
                    PRINT_INT(storageCfg.hddStorage.alert);
                    break;

                case STORAGE_STRG_ALT_RMNG_CPCTY:
                    PRINT_INT(storageCfg.hddStorage.remainingCapacity);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

        if(retVal != CMD_SUCCESS)
		{
			break;
		}

	}

	return retVal;
}

static NET_CMD_STATUS_e setStorageConfig(CHARPTR *reqStr)
{
	STORAGE_CONFIG_t			storageCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8 						tmp;

	do
	{
		if((reqStr == NULL) || (*reqStr == NULL))
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_STORAGE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadStorageConfig(&storageCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case STORAGE_HDD_FULL_ACTION_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.hddFull.actionMode = val;
                    break;

                case STORAGE_HDD_FULL_PERCENTAGE_CLEAN:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.hddFull.percentCleanup = val;
                    break;

                case STORAGE_RECORD_RETENTATION_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.recordRetentionStatus = val;
                    break;

                case STORAGE_RECORD_RETENTATION_TYPE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.recordRetentionType = val;
                    break;

                case STORAGE_DRIVE_WISE_RECORD_CLEANUP_DAYS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.driveWiseRecordCleanupByDays = val;
                    break;

                case (STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START) ... (STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.cameraWiseRecordCleanupByDays[(tmp - STORAGE_CAMERA_WISE_RECORD_CLEANUP_DAYS_CAM_START)] = val;
                    break;

                case STORAGE_BACKUP_RETENTATION_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.backUpRetentionStatus = val;
                    break;

                case (STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START) ... (STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.cameraWiseBackUpCleanupByDays[(tmp - STORAGE_CAMERA_WISE_BACKUP_CLEANUP_DAYS_CAM_START)] = val;
                    break;

                case STORAGE_STRG_ALT_ALERT:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.hddStorage.alert = val;
                    break;

                case STORAGE_STRG_ALT_RMNG_CPCTY:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    storageCfg.hddStorage.remainingCapacity = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteStorageConfig(&storageCfg);
        if(retVal != CMD_SUCCESS)
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

    if((reqStr != NULL) && (*reqStr != NULL))
    {
        (*reqStr)++;
    }

	return retVal;
}

static NET_CMD_STATUS_e defaultStorageConfig(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltStorageConfig();
}

/** ******************************************************************************************* **/
/**                            SCHEDULE BACKUP SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSchedBackUpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					 fieldLoop;
	UINT16					 indexLoop;
	SCHEDULE_BACKUP_CONFIG_t schedBackUpCfg;
	UINT16					 outLen = 0;
	NET_CMD_STATUS_e	     retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadScheduleBackupConfig(&schedBackUpCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SCHEDULE_BACKUP_BACKUP:
                    PRINT_INT(schedBackUpCfg.scheduleBackup);
                    break;

                case SCHEDULE_BACKUP_MODE:
                    PRINT_INT(schedBackUpCfg.mode);
                    break;

                case SCHEDULE_BACKUP_EVERY_HOUR_MODE:
                    PRINT_INT(schedBackUpCfg.everyHourMode);
                    break;

                case SCHEDULE_BACKUP_EVERY_DAY_BKUP_HOUR:
                    PRINT_INT(schedBackUpCfg.everydayBackup.hour);
                    break;

                case SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_DAYS:
                    PRINT_INT(schedBackUpCfg.weeklyBackup.weekday);
                    break;

                case SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_HOUR:
                    PRINT_INT(schedBackUpCfg.weeklyBackup.hour);
                    break;

                case (SCHEDULE_BACKUP_CAMERA_MASK_START)...(SCHEDULE_BACKUP_CAMERA_MASK_END):
                    PRINT_INT64(schedBackUpCfg.camera.bitMask[fieldLoop - SCHEDULE_BACKUP_CAMERA_MASK_START]);
                    break;

                case SCHEDULE_BACKUP_BKUP_LOCATION:
                    PRINT_INT(schedBackUpCfg.backupLocation);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setSchedBackUpCfg(CHARPTR *reqStr)
{
	SCHEDULE_BACKUP_CONFIG_t 	schedBackUpCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
    UINT8 						fieldLoop;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SCHEDULE_BACKUP_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadScheduleBackupConfig(&schedBackUpCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

            fieldLoop = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldLoop)
			{
                case SCHEDULE_BACKUP_BACKUP:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.scheduleBackup = val;
                    break;

                case SCHEDULE_BACKUP_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.mode = val;
                    break;

                case SCHEDULE_BACKUP_EVERY_HOUR_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.everyHourMode = val;
                    break;

                case SCHEDULE_BACKUP_EVERY_DAY_BKUP_HOUR:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.everydayBackup.hour = val;
                    break;

                case SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_DAYS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.weeklyBackup.weekday = val;
                    break;

                case SCHEDULE_BACKUP_WEEKLY_BKUP_WEEK_HOUR:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.weeklyBackup.hour = val;
                    break;

                case (SCHEDULE_BACKUP_CAMERA_MASK_START)...(SCHEDULE_BACKUP_CAMERA_MASK_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.camera.bitMask[fieldLoop - SCHEDULE_BACKUP_CAMERA_MASK_START] = val;
                    break;

                case SCHEDULE_BACKUP_BKUP_LOCATION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    schedBackUpCfg.backupLocation = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteScheduleBackupConfig(&schedBackUpCfg);
        if(retVal != CMD_SUCCESS)
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultSchedBackUpCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltScheduleBackupConfig();
}

/** ******************************************************************************************* **/
/**                               MANUAL BACKUP SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getManBackUpCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					 fieldLoop;
	UINT16					 indexLoop;
	MANUAL_BACKUP_CONFIG_t 	 manBackUpCfg;
	UINT16					 outLen = 0;
	NET_CMD_STATUS_e	     retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadManualBackupConfig(&manBackUpCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case MANUAL_BACKUP_ENABLE:
                    PRINT_INT(manBackUpCfg.manualBackup);
                    break;

                case MANUAL_BACKUP_DURATION:
                    PRINT_INT(manBackUpCfg.duration);
                    break;

                case (MANUAL_BACKUP_CAMERA_MASK_START)...(MANUAL_BACKUP_CAMERA_MASK_END):
                    PRINT_INT64(manBackUpCfg.camera.bitMask[fieldLoop - MANUAL_BACKUP_CAMERA_MASK_START]);
                    break;

                case MANUAL_BACKUP_LOCATION:
                    PRINT_INT(manBackUpCfg.backupLocation)
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setManBackUpCfg(CHARPTR *reqStr)
{
	MANUAL_BACKUP_CONFIG_t 	 	manBackUpCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
    UINT8 						fieldLoop;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_MANUAL_BACKUP_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadManualBackupConfig(&manBackUpCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				break;
			}

            fieldLoop = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldLoop)
			{
                case MANUAL_BACKUP_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    manBackUpCfg.manualBackup = val;
                    break;

                case MANUAL_BACKUP_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    manBackUpCfg.duration = val;
                    break;

                case (MANUAL_BACKUP_CAMERA_MASK_START)...(MANUAL_BACKUP_CAMERA_MASK_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    manBackUpCfg.camera.bitMask[fieldLoop - MANUAL_BACKUP_CAMERA_MASK_START] = val;
                    break;

                case MANUAL_BACKUP_LOCATION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    manBackUpCfg.backupLocation = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteManualBackupConfig(&manBackUpCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultManBackUpCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltManualBackupConfig();
}

/** ******************************************************************************************* **/
/**                            EVENT AND ACTION SETTINGS                                        **/
/** ******************************************************************************************* **/

UINT16 getEvtActfield1(UINT16 fromField, UINT16 toField, BOOL action, ACTION_PARAMETERS_t *actionParam,UINT16PTR actionBits, CHARPTR respStringPtr, CAMERA_BIT_MASK_t *copyToCam, const UINT32 respStrLen)
{
    UINT16              outLen = 0;
    UINT16              fieldLoop;
    UINT64              bitField = 0;
    UINT8               maskId, totalCamera;
    UINT8               cameraCntIdx[CAMERA_MASK_MAX];
    UINT8               cameraCntOffset[CAMERA_MASK_MAX];

    memset(cameraCntIdx, 0, sizeof(cameraCntIdx));
    memset(cameraCntOffset, 0, sizeof(cameraCntOffset));
    totalCamera = getMaxCameraForCurrentVariant();

    /* calculating camera count offset and number of camera per camera bit mask */
    for (maskId = 0; maskId < CAMERA_MASK_MAX; maskId++)
    {
        /* store total number of cameras mapped till previous bit mask */
        cameraCntOffset[maskId] = (maskId == 0) ? 0 : cameraCntIdx[maskId-1];
        if (totalCamera <= CAMERA_BIT_WISE_MAX)
        {
            /* store total number of cameras mapped in single bit mask */
            cameraCntIdx[maskId] = totalCamera;
            break;
        }

        /* if total number of cameras greater than bit mask size, store max camera per bit mask */
        cameraCntIdx[maskId] = CAMERA_BIT_WISE_MAX;
        totalCamera = totalCamera - CAMERA_BIT_WISE_MAX;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case EVENT_ACTION_ENABLE:
                PRINT_INT(action);
                break;

            case (EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START)...(EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_END):
                maskId = fieldLoop - EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START;
                fillBitField(&actionParam->alarmRecord[cameraCntOffset[maskId]], cameraCntIdx[maskId], &bitField);
                PRINT_INT64(bitField);
                break;

            case (EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START)...(EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_END):
                maskId = fieldLoop - EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START;
                fillBitField(&actionParam->uploadImage[cameraCntOffset[maskId]], cameraCntIdx[maskId], &bitField);
                PRINT_INT64(bitField);
                break;

            case EVENT_ACTION_PARAMETER_EMAIL_ADDR:
                PRINT_STRING(actionParam->sendEmail.emailAddress);
                break;

            case EVENT_ACTION_PARAMETER_EMAIL_SUBJ:
                PRINT_STRING(actionParam->sendEmail.subject);
                break;

            case EVENT_ACTION_PARAMETER_EMAIL_MSG:
                PRINT_STRING(actionParam->sendEmail.message);
                break;

            case EVENT_ACTION_SEND_TCP:
                PRINT_STRING(actionParam->sendTcp);
                break;

            case EVENT_ACTION_SMS_MOB_NUM1:
                PRINT_STRING(actionParam->smsParameter.mobileNumber1);
                break;

            case EVENT_ACTION_SMS_MOB_NUM2:
                PRINT_STRING(actionParam->smsParameter.mobileNumber2);
                break;

            case EVENT_ACTION_SMS_MESSAGE:
                PRINT_STRING(actionParam->smsParameter.message);
                break;

            case EVENT_ACTION_GOTO_PRESET_CAM_NUM:
                PRINT_INT(actionParam->gotoPosition.cameraNumber);
                break;

            case EVENT_ACTION_GOTO_PRESET_PRESET_POS:
                PRINT_INT(actionParam->gotoPosition.presetPosition);
                break;

            case EVENT_ACTION_SYS_ALM_OUTPUT0:
                PRINT_INT(actionParam->systemAlarmOutput[0]);
                break;

            case EVENT_ACTION_SYS_ALM_OUTPUT1:
                PRINT_INT(actionParam->systemAlarmOutput[1]);
                break;

            case EVENT_ACTION_SYS_ALM_OUTPUT2:
                PRINT_INT(actionParam->systemAlarmOutput[2]);
                break;

            case EVENT_ACTION_SYS_ALM_OUTPUT3:
                PRINT_INT(actionParam->systemAlarmOutput[3]);
                break;

            case EVENT_ACTION_CAM_ALM_CAM_NUM:
                PRINT_INT(actionParam->cameraAlarmOutput.cameraNumber);
                break;

            case EVENT_ACTION_CAM_ALM_ALM0:
                PRINT_INT(actionParam->cameraAlarmOutput.alarm[0]);
                break;

            case EVENT_ACTION_CAM_ALM_ALM1:
                PRINT_INT(actionParam->cameraAlarmOutput.alarm[1]);
                break;

            case EVENT_ACTION_CAM_ALM_ALM2:
                PRINT_INT(actionParam->cameraAlarmOutput.alarm[2]);
                break;

            //for sytem event and action
            case (EVENT_ACTION_BITGRP_START)...(EVENT_ACTION_BITGRP_END):
                if(actionBits != NULL) //for sytem event and action
                {
                    PRINT_INT(*actionBits);
                    break;
                }
                else if (copyToCam != NULL) // for camera event and action
                {
                    PRINT_INT(0);
                    break;
                }

            /* FALL THROUGH */
            default:
                outLen = 0;
                break;
		}

        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(outLen == 0)
		{
			break;
		}
	}

	return outLen;
}

static NET_CMD_STATUS_e getCameraEACfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	CAMERA_EVENT_CONFIG_t 	 camEvtCfg;
	UINT16					 outLen = 0, fieldStrLen = 0;
	UINT16 					 startIdx;
	UINT16 					 camEvtIdx;
	UINT16 					 camIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;
    CAMERA_BIT_MASK_t	     copyToCamera;

    memset(&copyToCamera, 0, sizeof(copyToCamera));
	camIdx = getMaxCameraForCurrentVariant();
	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		getXYIndx(startIdx, MAX_CAMERA_EVENT, &camIdx, &camEvtIdx);
		ReadSingleCameraEventConfig(camIdx, camEvtIdx, &camEvtCfg);

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
        }

        if((fieldStrLen = getEvtActfield1(fromField, toField, camEvtCfg.action, &(camEvtCfg.actionParam),
                                          NULL, respStringPtr + outLen, &copyToCamera, respStrLen - outLen)) == 0)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        //Validate Buffer size for add last two character including NULL
		outLen += fieldStrLen;
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

BOOL setEvtActField1(UINT16 fieldId, BOOL *action,ACTION_PARAMETERS_t *actionParam, UINT16PTR actionBits, CHARPTR *reqStr, CAMERA_BIT_MASK_t *copyToCam)
{
    BOOL    writeStatus = FAIL;
    UINT64  val = 0;
    UINT8   maskId, totalCamera;
    UINT8   cameraCntIdx[CAMERA_MASK_MAX];
    UINT8   cameraCntOffset[CAMERA_MASK_MAX];

    memset(cameraCntIdx, 0, sizeof(cameraCntIdx));
    memset(cameraCntOffset, 0, sizeof(cameraCntOffset));
    totalCamera = getMaxCameraForCurrentVariant();

    /* calculating camera count offset and number of camera per camera bit mask */
    for (maskId = 0; maskId < CAMERA_MASK_MAX; maskId++)
    {
        /* store total number of cameras mapped till previous bit mask */
        cameraCntOffset[maskId] = (maskId == 0) ? 0 : cameraCntIdx[maskId-1];
        if (totalCamera <= CAMERA_BIT_WISE_MAX)
        {
            /* store total number of cameras mapped in single bit mask */
            cameraCntIdx[maskId] = totalCamera;
            break;
        }

        /* if total number of cameras greater than bit mask size, store max camera per bit mask */
        cameraCntIdx[maskId] = CAMERA_BIT_WISE_MAX;
        totalCamera = totalCamera - CAMERA_BIT_WISE_MAX;
    }

	switch(fieldId)
	{
        case EVENT_ACTION_ENABLE:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            *action = val;
            break;

        case (EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START)...(EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_END):
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            maskId = fieldId - EVENT_ACTION_PARAMETER_ALM_RECORD_BIT_FIELD_START;
            fillArrayFrmBitField(&actionParam->alarmRecord[cameraCntOffset[maskId]], cameraCntIdx[maskId], val);
            break;

        case (EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START)...(EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_END):
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            maskId = fieldId - EVENT_ACTION_PARAMETER_UPLD_IMG_BIT_FIELD_START;
            fillArrayFrmBitField(&actionParam->uploadImage[cameraCntOffset[maskId]], cameraCntIdx[maskId], val);
            break;

        case EVENT_ACTION_PARAMETER_EMAIL_ADDR:
            writeStatus = ParseStr(reqStr, FSP, actionParam->sendEmail.emailAddress, sizeof(actionParam->sendEmail.emailAddress));
            break;

        case EVENT_ACTION_PARAMETER_EMAIL_SUBJ:
            writeStatus = ParseStr(reqStr, FSP, actionParam->sendEmail.subject, sizeof(actionParam->sendEmail.subject));
            break;

        case EVENT_ACTION_PARAMETER_EMAIL_MSG:
            writeStatus = ParseStr(reqStr, FSP, actionParam->sendEmail.message, sizeof(actionParam->sendEmail.message));
            break;

        case EVENT_ACTION_SEND_TCP:
            writeStatus = ParseStr(reqStr, FSP, actionParam->sendTcp, sizeof(actionParam->sendTcp));
            break;

        case EVENT_ACTION_SMS_MOB_NUM1:
            writeStatus = ParseStr(reqStr, FSP, actionParam->smsParameter.mobileNumber1, sizeof(actionParam->smsParameter.mobileNumber1));
            break;

        case EVENT_ACTION_SMS_MOB_NUM2:
            writeStatus = ParseStr(reqStr, FSP, actionParam->smsParameter.mobileNumber2, sizeof(actionParam->smsParameter.mobileNumber2));
            break;

        case EVENT_ACTION_SMS_MESSAGE:
            writeStatus = ParseStr(reqStr, FSP, actionParam->smsParameter.message, sizeof(actionParam->smsParameter.message));
            break;

        case EVENT_ACTION_GOTO_PRESET_CAM_NUM:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->gotoPosition.cameraNumber = val;
            break;

        case EVENT_ACTION_GOTO_PRESET_PRESET_POS:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->gotoPosition.presetPosition = val;
            break;

        case EVENT_ACTION_SYS_ALM_OUTPUT0:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->systemAlarmOutput[0] = val;
            break;

        case EVENT_ACTION_SYS_ALM_OUTPUT1:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->systemAlarmOutput[1] = val;
            break;

        case EVENT_ACTION_SYS_ALM_OUTPUT2:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->systemAlarmOutput[2] = val;
            break;

        case EVENT_ACTION_SYS_ALM_OUTPUT3:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->systemAlarmOutput[3] = val;
            break;

        case EVENT_ACTION_CAM_ALM_CAM_NUM:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->cameraAlarmOutput.cameraNumber = val;
            break;

        case EVENT_ACTION_CAM_ALM_ALM0:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->cameraAlarmOutput.alarm[0] = val;
            break;

        case EVENT_ACTION_CAM_ALM_ALM1:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->cameraAlarmOutput.alarm[1] = val;
            break;

        case EVENT_ACTION_CAM_ALM_ALM2:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            actionParam->cameraAlarmOutput.alarm[2] = val;
            break;

        case (EVENT_ACTION_BITGRP_START)...(EVENT_ACTION_BITGRP_END):
            if(actionBits != NULL) //for sytem event and action
            {
                writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                *actionBits = val;
            }
            else if (copyToCam != NULL) // for camera event and action
            {
                writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                copyToCam->bitMask[fieldId - EVENT_ACTION_BITGRP_START] = val;
            }
            break;

        default:
            writeStatus = FAIL;
            break;
	}

	return writeStatus;
}

static NET_CMD_STATUS_e setCameraEACfg1(CHARPTR *reqStr)
{
	CAMERA_EVENT_CONFIG_t 	 	camEvtCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16 						camIdx;
	UINT16 						camEvtIdx;

	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_CAMERA_EVENT_ACTION_PARAM_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		getXYIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_CAMERA_EVENT, &camIdx, &camEvtIdx);
		ReadSingleCameraEventConfig(camIdx, camEvtIdx, &camEvtCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
				break;
			}

            writeStatus = setEvtActField1(CLIENT_TO_OUR_INDEX(fieldId), &(camEvtCfg.action), &(camEvtCfg.actionParam), NULL, reqStr, &(camEvtCfg.copyToCam));
            if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSingleCameraEventConfig(camIdx, camEvtIdx, &camEvtCfg);
        if(retVal != CMD_SUCCESS)
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		(*reqStr)++;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

	*reqStr = *reqStr + 1;
	return retVal;
}

static NET_CMD_STATUS_e defaultCameraEACfg1(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId, camIdx, camEvtIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYIndx(idxId, MAX_CAMERA_EVENT, &camIdx, &camEvtIdx);
        if(CMD_SUCCESS != DfltSingleCameraEventConfig(camIdx, camEvtIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static UINT16 getEvtActfield2(UINT16 fromField, UINT16 toField, WEEKLY_ACTION_SCHEDULE_t *weeklySchedule,CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16  outLen = 0;
    UINT16  fieldLoop;

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case EVENT_ACTION_WEEKSCHED_ENTIRE_DAY:
                PRINT_INT(weeklySchedule->actionEntireDay);
                break;

            case EVENT_ACTION_WEEKSCHED_ENTIRE_DAY_ACTION:
                PRINT_INT(weeklySchedule->entireDayAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[0].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[0].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[0].scheduleAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[1].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[1].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[1].scheduleAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[2].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[2].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[2].scheduleAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[3].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[3].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[3].scheduleAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[4].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[4].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[4].scheduleAction.actionBitGroup);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_STRT_TIME:
                PRINT_TIME(weeklySchedule->actionControl[5].startTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_END_TIME:
                PRINT_TIME(weeklySchedule->actionControl[5].endTime);
                break;

            case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_SCHED_ACT_BITFIELD:
                PRINT_INT(weeklySchedule->actionControl[5].scheduleAction.actionBitGroup);
                break;

            default:
                outLen = 0;
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(outLen == 0)
		{
			break;
		}
	}

	return outLen;
}

static NET_CMD_STATUS_e getCameraEACfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	CAMERA_EVENT_CONFIG_t 	 camEvtCfg;
	UINT16					 outLen = 0, fieldStrLen = 0;
	UINT16 					 startIdx;
	UINT16 					 camEvtIdx, tmp;
	UINT32 					 camIdx;
	UINT16 					 weekDaysIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;

	camEvtIdx = MAX_CAMERA_EVENT;
	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
        getXYZIndx(startIdx, MAX_CAMERA_EVENT, MAX_WEEK_DAYS, &camIdx, &tmp, &weekDaysIdx);

		//Read configuration only when camera event index changes
		if(tmp != camEvtIdx)
		{
			camEvtIdx = tmp;
			ReadSingleCameraEventConfig(camIdx, camEvtIdx, &camEvtCfg);
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
        }

        if((fieldStrLen = getEvtActfield2(fromField, toField,&(camEvtCfg.weeklySchedule[weekDaysIdx]), (respStringPtr + outLen), respStrLen - outLen)) == 0)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        //Validate Buffer size for add last two character including NULL
		outLen += fieldStrLen;
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static BOOL setEvtActField2(UINT16 fieldId, WEEKLY_ACTION_SCHEDULE_t *weeklySchedule, CHARPTR *reqStr)
{
    BOOL    writeStatus = FAIL;
    UINT64  val = 0;

	switch(fieldId)
	{
        case EVENT_ACTION_WEEKSCHED_ENTIRE_DAY:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionEntireDay = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ENTIRE_DAY_ACTION:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->entireDayAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[0].startTime.hour = val / 100;
            weeklySchedule->actionControl[0].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[0].endTime.hour = val / 100;
            weeklySchedule->actionControl[0].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL0_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[0].scheduleAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[1].startTime.hour = val / 100;
            weeklySchedule->actionControl[1].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[1].endTime.hour = val / 100;
            weeklySchedule->actionControl[1].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL1_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[1].scheduleAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[2].startTime.hour = val / 100;
            weeklySchedule->actionControl[2].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[2].endTime.hour = val / 100;
            weeklySchedule->actionControl[2].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL2_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[2].scheduleAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[3].startTime.hour = val / 100;
            weeklySchedule->actionControl[3].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[3].endTime.hour = val / 100;
            weeklySchedule->actionControl[3].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL3_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[3].scheduleAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[4].startTime.hour = val / 100;
            weeklySchedule->actionControl[4].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[4].endTime.hour = val / 100;
            weeklySchedule->actionControl[4].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL4_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[4].scheduleAction.actionBitGroup = val;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_STRT_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[5].startTime.hour = val / 100;
            weeklySchedule->actionControl[5].startTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_END_TIME:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[5].endTime.hour = val / 100;
            weeklySchedule->actionControl[5].endTime.minute = val % 100;
            break;

        case EVENT_ACTION_WEEKSCHED_ACT_CTRL5_SCHED_ACT_BITFIELD:
            writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
            weeklySchedule->actionControl[5].scheduleAction.actionBitGroup = val;
            break;

        default:
            writeStatus = FAIL;
            break;
	}

	return writeStatus;
}

static NET_CMD_STATUS_e setCameraEACfg2(CHARPTR *reqStr)
{
	CAMERA_EVENT_CONFIG_t 	 	camEvtCfg[MAX_CAMERA][MAX_CAMERA_EVENT];
	UINT64 						fieldId;
	UINT64 						idxId;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT32						camIdx;
	UINT16 						camEvtIdx, tmp, weekDaysIdx;
	UINT8					    cameraId;

	camEvtIdx = MAX_CAMERA_EVENT;
	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_CAMERA_EVENT_SCHEDUL_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

        //read configuration when camera event index changes
		getXYZIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_CAMERA_EVENT, MAX_WEEK_DAYS, &camIdx, &tmp, &weekDaysIdx);
		if(tmp != camEvtIdx)
		{
			camEvtIdx = tmp;

			if(SUCCESS != ReadSingleCameraEventConfig(camIdx, camEvtIdx, &camEvtCfg[camIdx][camEvtIdx]))
			{
                EPRINT(NETWORK_MANAGER," Failed to Read Single Camera CamIdx:%d, CamEvtIdx:%d", camIdx, camEvtIdx);
				retVal = CMD_INVALID_INDEX_ID;
				break;
			}
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
                EPRINT(NETWORK_MANAGER, "fail to parse");
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
				break;
			}

            writeStatus = setEvtActField2(CLIENT_TO_OUR_INDEX(fieldId), &(camEvtCfg[camIdx][camEvtIdx].weeklySchedule[weekDaysIdx]),reqStr);
			if(writeStatus == FAIL)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	if(retVal == CMD_SUCCESS)
	{
        BOOL                    isAlarmRecordAllCamSelected = TRUE;
        BOOL                    isImageUploadAllCamSelected = TRUE;
        CAMERA_EVENT_CONFIG_t   curCamEvtCfg;

        /* Check alarm recording is enabled or not for all camera in source camera config */
        for(cameraId = 0; cameraId < getMaxCameraForCurrentVariant(); cameraId++)
        {
            if (FALSE == camEvtCfg[camIdx][camEvtIdx].actionParam.alarmRecord[cameraId])
            {
                /* Alarm recording is disabled for given camera */
                isAlarmRecordAllCamSelected = FALSE;
                break;
            }
        }

        /* Check image upload is enabled or not for all camera in source camera config */
        for(cameraId = 0; cameraId < getMaxCameraForCurrentVariant(); cameraId++)
        {
            if (FALSE == camEvtCfg[camIdx][camEvtIdx].actionParam.uploadImage[cameraId])
            {
                /* Image upload is disabled for given camera */
                isImageUploadAllCamSelected = FALSE;
                break;
            }
        }

        /* Get copy to camera mask */
        for(cameraId = 0; cameraId < getMaxCameraForCurrentVariant(); cameraId++)
		{
            /* Is current camera added in mask? */
            if (GET_CAMERA_MASK_BIT(camEvtCfg[camIdx][camEvtIdx].copyToCam, cameraId) == 0)
			{
                /* Camera not added in mask */
                continue;
            }

            /* Get source camera event and action temp config copy */
            curCamEvtCfg = camEvtCfg[camIdx][camEvtIdx];

            /* If alarm recording is enabled for all cameras then we don't have to apply any logic */
            if (FALSE == isAlarmRecordAllCamSelected)
            {
                /* If source camera alarm recording selected in source camera then select destination camera
                 * alarm recording in destination camera instead of source camera */
                if (TRUE == curCamEvtCfg.actionParam.alarmRecord[camIdx])
                {
                    /* Disable source camera alarm recording and enable destination camera alarm recording in destination camera config */
                    curCamEvtCfg.actionParam.alarmRecord[camIdx] = FALSE;
                    curCamEvtCfg.actionParam.alarmRecord[cameraId] = TRUE;
                }
            }

            /* If image upload is enabled for all cameras then we don't have to apply any logic */
            if (FALSE == isImageUploadAllCamSelected)
            {
                /* If source camera image upload selected in source camera then select destination camera
                 * image upload in destination camera instead of source camera */
                if (TRUE == curCamEvtCfg.actionParam.uploadImage[camIdx])
                {
                    /* Disable source camera image upload and enable destination camera image upload in destination camera config */
                    curCamEvtCfg.actionParam.uploadImage[camIdx] = FALSE;
                    curCamEvtCfg.actionParam.uploadImage[cameraId] = TRUE;
                }
            }

            /* Copy source camera's event and action configuration to destination camera */
            retVal = WriteSingleCameraEventConfig(cameraId, camEvtIdx, &curCamEvtCfg);
            if(retVal != CMD_SUCCESS)
            {
                retVal = CMD_PROCESS_ERROR;
                break;
            }
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e defaultCameraEACfg2(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;
    UINT32 camIdx;
    UINT16 camEvtIdx, weekDayIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYZIndx(idxId, MAX_CAMERA_EVENT, MAX_WEEK_DAYS,  &camIdx, &camEvtIdx , &weekDayIdx);
        if(CMD_SUCCESS != DfltSingleCameraEventConfig(camIdx, camEvtIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getSensorEaParamCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	SENSOR_EVENT_CONFIG_t 	 sensorEvtCfg;
	UINT16					 outLen = 0, fieldStrLen = 0;
	UINT16 					 startIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;

	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		//get camera index
		ReadSingleSensorEventConfig(startIdx, &sensorEvtCfg);

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
        }

        if((fieldStrLen = getEvtActfield1(fromField, toField, sensorEvtCfg.action, &(sensorEvtCfg.actionParam), NULL, respStringPtr + outLen,NULL, respStrLen - outLen)) == 0)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        //Validate Buffer size for add last two character including NULL
		outLen += fieldStrLen;
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setSensorEaParamCfg1(CHARPTR *reqStr)
{
	SENSOR_EVENT_CONFIG_t 	 	sensorEvtCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;

	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
            EPRINT(NETWORK_MANAGER, "fail to parse");
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SENSOR_EVENT_ACTION_PARAM_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadSingleSensorEventConfig(CLIENT_TO_OUR_INDEX(idxId), &sensorEvtCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			writeStatus = setEvtActField1(CLIENT_TO_OUR_INDEX(fieldId), &(sensorEvtCfg.action), &(sensorEvtCfg.actionParam), NULL, reqStr, NULL);
			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSingleSensorEventConfig(CLIENT_TO_OUR_INDEX(idxId), &sensorEvtCfg);
        if(retVal != CMD_SUCCESS)
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		(*reqStr)++;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

	*reqStr = *reqStr + 1;
	return retVal;
}

static NET_CMD_STATUS_e defaultSensorEaParamCfg1(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleSensorEventConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getSensorEaParamCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	SENSOR_EVENT_CONFIG_t 	 sensorEvtCfg;
	UINT16					 outLen = 0, fieldStrLen = 0;
	UINT32 					 startIdx;
	UINT16 					 tmp;
	UINT16 					 sensorIdx, weekDaysIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;

	sensorIdx = MAX_SENSOR;
	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		getXYIndx(startIdx, MAX_WEEK_DAYS, &tmp, &weekDaysIdx);

		//Read configuration only when camera event index changes
		if(tmp != sensorIdx)
		{
			sensorIdx = tmp;
			ReadSingleSensorEventConfig(sensorIdx, &sensorEvtCfg);
		}

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
        }

        if((fieldStrLen = getEvtActfield2(fromField, toField, &(sensorEvtCfg.weeklySchedule[weekDaysIdx]), (respStringPtr + outLen), respStrLen - outLen)) == 0)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        //Validate Buffer size for add last two character including NULL
		outLen += fieldStrLen;
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setSensorEaParamCfg2(CHARPTR *reqStr)
{
	SENSOR_EVENT_CONFIG_t 		sensorEvtCfg[MAX_SENSOR];
	UINT16 						availableChannel[MAX_SENSOR];
    UINT8						channelCnt = 0;
	UINT64 						fieldId = 0;
	UINT64 						idxId;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16						sensorIdx;
	UINT16 						tmp, weekDaysIdx;
	UINT32 						maxSensorEvtActIndex;

	maxSensorEvtActIndex = GET_MAX_INDEX(MAX_SENSOR, MAX_WEEK_DAYS);
	sensorIdx = maxSensorEvtActIndex;
	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SENSOR_EVENT_SCHEDULE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		getXYIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_WEEK_DAYS, &tmp, &weekDaysIdx);

		//read configuration when camera event index changes
		if(tmp != sensorIdx)
		{
			sensorIdx = tmp;
			ReadSingleSensorEventConfig(sensorIdx, &sensorEvtCfg[sensorIdx]);
			availableChannel[channelCnt] = sensorIdx;
			channelCnt++;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
				retVal = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

            writeStatus = setEvtActField2(CLIENT_TO_OUR_INDEX(fieldId), &(sensorEvtCfg[sensorIdx].weeklySchedule[weekDaysIdx]), reqStr);
			if(writeStatus == FAIL)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;

	if(retVal == CMD_SUCCESS)
	{
		//Write configuration only to available channels
		while(channelCnt > 0)
		{
			channelCnt--;
			sensorIdx = availableChannel[channelCnt];
            retVal = WriteSingleSensorEventConfig(sensorIdx,&sensorEvtCfg[sensorIdx]);
            if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e defaultSensorEaParamCfg2(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId, sensorIdx, weekDaysIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYIndx(idxId, MAX_WEEK_DAYS, &sensorIdx, &weekDaysIdx);
        if(CMD_SUCCESS != DfltSingleSensorEventConfig(sensorIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getSystemEaParamCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	SYSTEM_EVENT_CONFIG_t 	 systemEvtCfg;
	UINT16					 outLen = 0, fieldStrLen = 0;
	UINT32 					 startIdx;
	NET_CMD_STATUS_e         retVal = CMD_SUCCESS;

	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
		ReadSingleSystemEventConfig(startIdx, &systemEvtCfg);

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
        }

        fieldStrLen = getEvtActfield1(fromField, toField, systemEvtCfg.action, &systemEvtCfg.actionParam, &systemEvtCfg.actionBits.actionBitGroup, respStringPtr + outLen, NULL, respStrLen - outLen);
        if(fieldStrLen == 0)
		{
			retVal = CMD_INVALID_FIELD_VALUE;
			break;
		}

        //Validate Buffer size for add last two character including NULL
		outLen += fieldStrLen;
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setSystemEaParamCfg(CHARPTR *reqStr)
{
	SYSTEM_EVENT_CONFIG_t 	 	systemEvtCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;

	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SYSTEM_EVENT_ACTION_PARAM_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadSingleSystemEventConfig(CLIENT_TO_OUR_INDEX(idxId), &systemEvtCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				writeStatus = FAIL;
				retVal = CMD_INVALID_SYNTAX;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

            writeStatus = setEvtActField1(CLIENT_TO_OUR_INDEX(fieldId), &(systemEvtCfg.action), &(systemEvtCfg.actionParam), &(systemEvtCfg.actionBits.actionBitGroup), reqStr, NULL);
			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

		if(writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSingleSystemEventConfig(CLIENT_TO_OUR_INDEX(idxId), &systemEvtCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

    //increment address to retrieve next value
	}while(**reqStr != EOT);

	*reqStr = *reqStr + 1;
	return retVal;
}

static NET_CMD_STATUS_e defaultSystemEaParamCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleSystemEventConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                            COSEC PRE-RECORD SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getCosecRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	COSEC_REC_PARAM_CONFIG_t	cosecRecCfg;
	UINT16						fieldLoop;
	UINT16						indexLoop;
	UINT16						outLen = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleCosecPreRecConfig(indexLoop, &cosecRecCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case COSEC_REC_ENABLE:
                    PRINT_INT(cosecRecCfg.enable);
                    break;

                case COSEC_PRE_REC_DURATION:
                    PRINT_INT(cosecRecCfg.preRecDuration);
                    break;

                case (COSEC_REC_COPY_TO_CAMERA_START)...(COSEC_REC_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;

        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setCosecRecordCfg(CHARPTR *reqStr)
{
	COSEC_REC_PARAM_CONFIG_t	cosecRecCfg;
    BOOL						writeStatus = SUCCESS;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	UINT64						indexId;
	UINT64						fieldId;
	UINT64						fieldVal = 0;
	UINT8						camId;
    CAMERA_BIT_MASK_t		    copyToCam;

    memset(&copyToCam, 0, sizeof(copyToCam));
	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_COSEC_RECORD_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleCosecPreRecConfig(indexId, &cosecRecCfg);
        while(**reqStr != EOI)
        {
            if(ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                EPRINT(NETWORK_MANAGER, "fail to parse");
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case COSEC_REC_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cosecRecCfg.enable = fieldVal;
                    break;

                case COSEC_PRE_REC_DURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    cosecRecCfg.preRecDuration = fieldVal;
                    break;

                case (COSEC_REC_COPY_TO_CAMERA_START)...(COSEC_REC_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCam.bitMask[fieldId - COSEC_REC_COPY_TO_CAMERA_START] = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleCosecPreRecConfig(camId, &cosecRecCfg);
                if(retVal != CMD_SUCCESS)
                {
                    writeStatus = FAIL;
                    break;
                }
            }
        }

        if (writeStatus == FAIL)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultCosecRecordCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleCosecPreRecConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                               CAMERA ALARM SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getCameraAlmCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	CAMERA_ALARM_CONFIG_t 	camAlmCfg;
	UINT16					outLen = 0, almIdx, camIdx;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		getXYIndx(indexLoop, MAX_CAMERA_ALARM, &camIdx, &almIdx);
		ReadSingleCameraAlarmConfig(camIdx, almIdx, &camAlmCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case CAM_ALM_ACTV_MODE:
                    PRINT_INT(camAlmCfg.activeMode);
                    break;

                case CAM_ALM_ACTV_TIME:
                    PRINT_INT(camAlmCfg.activeTime);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setCameraAlmCfg(CHARPTR *reqStr)
{
	CAMERA_ALARM_CONFIG_t 		camAlmCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16						camIdx, tmp;
	UINT16 						almIdx;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		(*reqStr)++;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_CAMERA_ALARM_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		getXYIndx(CLIENT_TO_OUR_INDEX(idxId), MAX_CAMERA_ALARM, &camIdx, &almIdx);

		//read configuration when camera index changes
		ReadSingleCameraAlarmConfig(camIdx, almIdx, &camAlmCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case CAM_ALM_ACTV_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    camAlmCfg.activeMode = val;
                    break;

                case CAM_ALM_ACTV_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    camAlmCfg.activeTime = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		if(retVal != CMD_SUCCESS)
		{
			break;
		}

        retVal = WriteSingleCameraAlarmConfig(camIdx, almIdx, &camAlmCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultCameraAlmCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 idxId, camIdx, almIdx;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
		getXYIndx(idxId, MAX_CAMERA_ALARM, &camIdx, &almIdx);
        if(CMD_SUCCESS != DfltSingleCameraAlarmConfig(camIdx, almIdx))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                              STATIC ROUTING SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getDfltRoutingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	STATIC_ROUTING_CONFIG_t	dflRoutingCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadStaticRoutingConfig(&dflRoutingCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case STAT_ROUTE_DFLT_PORT:
                    PRINT_INT(dflRoutingCfg.defaultPort);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setDfltRoutingCfg(CHARPTR *reqStr)
{
	STATIC_ROUTING_CONFIG_t		dflRoutingCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16 						tmp;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_DEFAULT_ROUTING_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadStaticRoutingConfig(&dflRoutingCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case STAT_ROUTE_DFLT_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    dflRoutingCfg.defaultPort = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteStaticRoutingConfig(&dflRoutingCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;

	return retVal;
}

static NET_CMD_STATUS_e defaultDfltRoutingCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltStaticRoutingConfig();
}

static NET_CMD_STATUS_e getStaticRoutingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	STATIC_ROUTING_CONFIG_t	staticRoute;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	ReadStaticRoutingConfig(&staticRoute);
	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case STAT_ROUTE_NW_ADDR:
                    PRINT_STRING(staticRoute.entry[indexLoop].networkAddr);
                    break;

                case STAT_ROUTE_SUBNET_MASK:
                    PRINT_INT(staticRoute.entry[indexLoop].subnetMask);
                    break;

                case STAT_ROUTE_ROUTE_PORT:
                    PRINT_INT(staticRoute.entry[indexLoop].routePort);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setStaticRoutingCfg(CHARPTR *reqStr)
{
	STATIC_ROUTING_CONFIG_t		staticRoute;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8 						routingIdx, tmp;

	ReadStaticRoutingConfig(&staticRoute);

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		routingIdx = CLIENT_TO_OUR_INDEX(idxId);

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_STATIC_ROUTING_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case STAT_ROUTE_NW_ADDR:
                    writeStatus = ParseStr(reqStr, FSP , staticRoute.entry[routingIdx].networkAddr, sizeof(staticRoute.entry[routingIdx].networkAddr));
                    break;

                case STAT_ROUTE_SUBNET_MASK:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    staticRoute.entry[routingIdx].subnetMask = val;
                    break;

                case STAT_ROUTE_ROUTE_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    staticRoute.entry[routingIdx].routePort = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	if(writeStatus == SUCCESS)
	{
		retVal = WriteStaticRoutingConfig(&staticRoute);
	}

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultStaticRoutingCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltStaticRoutingConfig();
}

/** ******************************************************************************************* **/
/**                            MOBILE BROADBAND SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getBroadBandCfg1(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16              fieldLoop;
    UINT16              indexLoop;
    BROAD_BAND_CONFIG_t brdBndCfg;
    UINT16              outLen = 0;
    NET_CMD_STATUS_e    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadBroadBandConfig(&brdBndCfg);
		for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
		{
			for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
			{
				switch(fieldLoop)
				{
                    case BRD_BND_ACTV_PROFILE:
                        PRINT_INT(brdBndCfg.activeProfile);
                        break;

                    default:
                        retVal = CMD_INVALID_FIELD_VALUE;
                        break;
				}

                //Validate Buffer size for add last two character including NULL
                if(outLen > respStrLen - 2)
                {
                    EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                    outLen = respStrLen - 2;
                    break;
                }

				if(retVal != CMD_SUCCESS)
				{
					break;
				}
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setBroadBandCfg1(CHARPTR *reqStr)
{
    BROAD_BAND_CONFIG_t brdBndCfg;
    UINT64              fieldId;
    UINT64              idxId;
    UINT64              val = 0;
    NET_CMD_STATUS_e    retVal = CMD_SUCCESS;
    BOOL                writeStatus = FAIL;
    UINT16              tmp;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_BROADBAND_PROFILE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadBroadBandConfig(&brdBndCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case BRD_BND_ACTV_PROFILE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    brdBndCfg.activeProfile = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	if(writeStatus == SUCCESS)
	{
		retVal = WriteBraodBandConfig(&brdBndCfg);
	}

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultBroadBandCfg1(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltBroadBandConfig();
}

static NET_CMD_STATUS_e getBroadBandCfg2(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16              fieldLoop;
    UINT16              indexLoop;
    BROAD_BAND_CONFIG_t brdBndCfg;
    UINT16              outLen = 0;
    NET_CMD_STATUS_e    retVal = CMD_SUCCESS;

	ReadBroadBandConfig(&brdBndCfg);
	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case BRD_BND_PROFILE_NAME:
                    PRINT_STRING(brdBndCfg.broadBandCfg[indexLoop].profileName);
                    break;

                case BRD_BND_DIAL_NUM:
                    PRINT_STRING(brdBndCfg.broadBandCfg[indexLoop].dialNumber);
                    break;

                case BRD_BND_USR_NAME:
                    PRINT_STRING(brdBndCfg.broadBandCfg[indexLoop].userName);
                    break;

                case BRD_BND_USR_PWD:
                    PRINT_STRING(brdBndCfg.broadBandCfg[indexLoop].password);
                    break;

                case BRD_BND_APN:
                    PRINT_STRING(brdBndCfg.broadBandCfg[indexLoop].apn);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setBroadBandCfg2(CHARPTR *reqStr)
{
    BROAD_BAND_CONFIG_t brdBndCfg;
    UINT64              fieldId;
    UINT64              idxId;
    NET_CMD_STATUS_e    retVal = CMD_SUCCESS;
    BOOL                writeStatus = FAIL;
    UINT8               brdBndIdx, tmp;

	ReadBroadBandConfig(&brdBndCfg);

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_BROADBAND_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		brdBndIdx = CLIENT_TO_OUR_INDEX(idxId);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case BRD_BND_PROFILE_NAME:
                    writeStatus = ParseStr(reqStr, FSP, brdBndCfg.broadBandCfg[brdBndIdx].profileName, sizeof(brdBndCfg.broadBandCfg[brdBndIdx].profileName));
                    break;

                case BRD_BND_DIAL_NUM:
                    writeStatus = ParseStr(reqStr, FSP, brdBndCfg.broadBandCfg[brdBndIdx].dialNumber, sizeof(brdBndCfg.broadBandCfg[brdBndIdx].dialNumber));
                    break;

                case BRD_BND_USR_NAME:
                    writeStatus = ParseStr(reqStr, FSP, brdBndCfg.broadBandCfg[brdBndIdx].userName, sizeof(brdBndCfg.broadBandCfg[brdBndIdx].userName));
                    break;

                case BRD_BND_USR_PWD:
                    writeStatus = ParseStr(reqStr, FSP, brdBndCfg.broadBandCfg[brdBndIdx].password, sizeof(brdBndCfg.broadBandCfg[brdBndIdx].password));
                    break;

                case BRD_BND_APN:
                    writeStatus = ParseStr(reqStr, FSP, brdBndCfg.broadBandCfg[brdBndIdx].apn, sizeof(brdBndCfg.broadBandCfg[brdBndIdx].apn));
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	if(writeStatus == SUCCESS)
	{
		retVal = WriteBraodBandConfig(&brdBndCfg);
	}

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultBroadBandCfg2(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltBroadBandConfig();
}

/** ******************************************************************************************* **/
/**                                     SMS SETTINGS                                            **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSmsCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	SMS_CONFIG_t			smsCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSmsConfig(&smsCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SMS_MODE:
                    PRINT_INT(smsCfg.mode);
                    break;

                case SMS_SERVER:
                    PRINT_INT(smsCfg.smsServer);
                    break;

                case SMS_USER_NAME:
                    PRINT_STRING(smsCfg.userName);
                    break;

                case SMS_USER_PWD:
                    PRINT_STRING(smsCfg.password);
                    break;

                case SMS_SENDER_ID:
                    PRINT_STRING(smsCfg.sendorId);
                    break;

                case SMS_SEND_AS_FLASH:
                    PRINT_INT(smsCfg.sendAsFlash);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setSmsCfg(CHARPTR *reqStr)
{
	SMS_CONFIG_t				smsCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8 						tmp;

	ReadSmsConfig(&smsCfg);

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SMS_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case SMS_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    smsCfg.mode = val;
                    break;

                case SMS_SERVER:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    smsCfg.smsServer = val;
                    break;

                case SMS_USER_NAME:
                    writeStatus = ParseStr(reqStr, FSP, smsCfg.userName, sizeof(smsCfg.userName));
                    break;

                case SMS_USER_PWD:
                    writeStatus = ParseStr(reqStr, FSP, smsCfg.password, sizeof(smsCfg.password));
                    break;

                case SMS_SENDER_ID:
                    writeStatus = ParseStr(reqStr, FSP, smsCfg.sendorId, sizeof(smsCfg.sendorId));
                    break;

                case SMS_SEND_AS_FLASH:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    smsCfg.sendAsFlash = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	if(writeStatus == SUCCESS)
	{
		retVal = WriteSmsConfig(&smsCfg);
	}

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultSmsCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltSmsConfig();
}

/** ******************************************************************************************* **/
/**                               MANUAL RECORD SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getManualRecordCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	UINT16					outLen = 0;
	MANUAL_RECORD_CONFIG_t	manRecCfg;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        /* Validate Buffer size for add last two character including NULL */
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        ReadSingleManualRecordConfig(indexLoop, &manRecCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case MAN_RECORD_STATUS:
                    PRINT_INT(manRecCfg.manualRecordStatus);
                    break;

                case (MANUAL_COPY_TO_CAMERA_START)...(MANUAL_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            /* Validate Buffer size for add last two character including NULL */
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        /* Validate Buffer size */
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

	return retVal;
}

static NET_CMD_STATUS_e setManualRecordCfg(CHARPTR *reqStr)
{
	MANUAL_RECORD_CONFIG_t		manRecCfg;
	UINT64 						fieldId;
    UINT64 						indexId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT8 						camId;
    CAMERA_BIT_MASK_t			copyToCam;

    memset(&copyToCam, 0, sizeof(copyToCam));

    while(**reqStr != EOT)
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

        /* Increment SOI */
		*reqStr = *reqStr + 1;

        /* Get Index Id */
        if(SUCCESS != ParseStringGetVal(reqStr, &indexId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        /* Check invalid index id */
        if(indexId > (UINT64)totalIndexPerEveryTable[TBL_MANUAL_RECORD_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleManualRecordConfig(indexId, &manRecCfg);
		while(**reqStr != EOI)
		{
            /* Get filed string */
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case MAN_RECORD_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    manRecCfg.manualRecordStatus = val;
                    break;

                case (MANUAL_COPY_TO_CAMERA_START)...(MANUAL_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    copyToCam.bitMask[fieldId - MANUAL_COPY_TO_CAMERA_START] = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_ID;
				break;
			}
		}

        /* Increment for EOI */
        (*reqStr)++;
        if (writeStatus != SUCCESS)
		{
			break;
		}

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
		{
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
			{
                retVal = WriteSingleManualRecordConfig(camId, &manRecCfg);
                if(retVal != CMD_SUCCESS)
                {
                    DPRINT(SYS_LOG, "fail to write manual config");
                    break;
                }
			}
		}

        if (writeStatus == FAIL)
        {
            break;
        }
    }

    /* Increment for EOT */
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultManualRecordCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        if (CMD_SUCCESS != DfltSingleManualRecordConfig(indexLoop))
        {
            return CMD_PROCESS_ERROR;
        }
    }

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                              NETWORK DRIVE SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getNwDriveCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT16					indexLoop;
	NETWORK_DRIVE_CONFIG_t	nwDrvCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
		ReadSingleNetworkDriveConfig(indexLoop, &nwDrvCfg);

        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case NW_DRIVE_ENABLE:
                    PRINT_INT(nwDrvCfg.enable);
                    break;

                case NW_DRIVE_NAME:
                    PRINT_STRING(nwDrvCfg.name);
                    break;

                case NW_DRIVE_IP_ADDR:
                    PRINT_STRING(nwDrvCfg.ipAddr);
                    break;

                case NW_DRIVE_USR_NAME:
                    PRINT_STRING(nwDrvCfg.userName);
                    break;

                case NW_DRIVE_USR_PWD:
                    PRINT_STRING(nwDrvCfg.password);
                    break;

                case NW_DRIVE_FILE_SYS:
                    PRINT_INT(nwDrvCfg.fileSys);
                    break;

                case NW_DRIVE_DFLT_FOLDER:
                    PRINT_STRING(nwDrvCfg.dfltFolder);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setNwDriveCfg(CHARPTR *reqStr)
{
	NETWORK_DRIVE_CONFIG_t		nwDrvCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
	UINT16 						tmp;

	do
	{
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

		//check invalid index id
        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_NW_DRIVE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		ReadSingleNetworkDriveConfig(CLIENT_TO_OUR_INDEX(idxId), &nwDrvCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

			tmp = CLIENT_TO_OUR_INDEX(fieldId);
			switch(tmp)
			{
                case NW_DRIVE_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    nwDrvCfg.enable = val;
                    break;

                case NW_DRIVE_NAME:
                    writeStatus = ParseStr(reqStr, FSP, nwDrvCfg.name, sizeof(nwDrvCfg.name));
                    break;

                case NW_DRIVE_IP_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, nwDrvCfg.ipAddr, sizeof(nwDrvCfg.ipAddr));
                    break;

                case NW_DRIVE_USR_NAME:
                    writeStatus = ParseStr(reqStr, FSP, nwDrvCfg.userName, sizeof(nwDrvCfg.userName));
                    break;

                case NW_DRIVE_USR_PWD:
                    writeStatus = ParseStr(reqStr, FSP, nwDrvCfg.password, sizeof(nwDrvCfg.password));
                    break;

                case NW_DRIVE_FILE_SYS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    nwDrvCfg.fileSys = val;
                    break;

                case NW_DRIVE_DFLT_FOLDER:
                    writeStatus = ParseStr(reqStr, FSP, nwDrvCfg.dfltFolder, sizeof(nwDrvCfg.dfltFolder));
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

        if (writeStatus != SUCCESS)
		{
			break;
		}

        retVal = WriteSingleNetworkDriveConfig(CLIENT_TO_OUR_INDEX(idxId), &nwDrvCfg);
        if(retVal != CMD_SUCCESS)
		{
			break;
		}

		(*reqStr)++;

	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defaultNwDriveCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16  idxId;

	for(idxId = fromIndex; idxId <= toIndex; idxId++)
	{
        if(CMD_SUCCESS != DfltSingleNetworkDriveConfig(idxId))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                 IP CAMERA SETTINGS                                          **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getIpCameraCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	UINT16				indexLoop;
	IP_CAMERA_CONFIG_t 	ipCameraCfg;
	UINT16				outLen = 0;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }

		ReadSingleIpCameraConfig(indexLoop, &ipCameraCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case IP_CAMERA_CFG_BRAND:
                    PRINT_STRING(ipCameraCfg.brand);
                    break;

                case IP_CAMERA_CFG_MODEL:
                    PRINT_STRING(ipCameraCfg.model);
                    break;

                case IP_CAMERA_CFG_URL:
                    PRINT_STRING(ipCameraCfg.url);
                    break;

                case IP_CAMERA_CFG_ADDRESS:
                    PRINT_STRING(ipCameraCfg.cameraAddress);
                    break;

                case IP_CAMERA_CFG_HTTP_PORT:
                    PRINT_INT(ipCameraCfg.httpPort);
                    break;

                case IP_CAMERA_CFG_RTSP_PORT:
                    PRINT_INT(ipCameraCfg.rtspPort);
                    break;

                case IP_CAMERA_CFG_USERNAME:
                    PRINT_STRING(ipCameraCfg.username);
                    break;

                case IP_CAMERA_CFG_PASSWORD:
                    PRINT_STRING(ipCameraCfg.password);
                    break;

                case IP_CAMERA_CFG_ONVIF_SUPPORT_FLAG:
                    PRINT_INT(ipCameraCfg.onvifSupportF);
                    break;

                case IP_CAMERA_CFG_ONVIF_PORT:
                    PRINT_INT(ipCameraCfg.onvifPort);
                    break;

                case IP_CAMERA_CFG_RTSP_PROTOCOL:
                    PRINT_INT(ipCameraCfg.rtspProtocol);
                    break;

                case IP_CAMERA_CFG_MAC_ADDR:
                    PRINT_STRING(ipCameraCfg.macAddr);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setIpCameraCfg(CHARPTR *reqStr)
{
	IP_CAMERA_CONFIG_t 	ipCameraCfg;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId = 0;
	UINT64				fieldId = 0;
	UINT64				fieldVal = 0;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_IP_CAMERA_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleIpCameraConfig(indexId, &ipCameraCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);

            switch (fieldId)
            {
                case IP_CAMERA_CFG_BRAND:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.brand, sizeof(ipCameraCfg.brand));
                    break;

                case IP_CAMERA_CFG_MODEL:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.model, sizeof(ipCameraCfg.model));
                    break;

                case IP_CAMERA_CFG_URL:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.url, sizeof(ipCameraCfg.url));
                    break;

                case IP_CAMERA_CFG_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.cameraAddress, sizeof(ipCameraCfg.cameraAddress));
                    break;

                case IP_CAMERA_CFG_HTTP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipCameraCfg.httpPort = fieldVal;
                    break;

                case IP_CAMERA_CFG_RTSP_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipCameraCfg.rtspPort = fieldVal;
                    break;

                case IP_CAMERA_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.username, sizeof(ipCameraCfg.username));
                    break;

                case IP_CAMERA_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.password, sizeof(ipCameraCfg.password));
                    break;

                case IP_CAMERA_CFG_ONVIF_SUPPORT_FLAG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipCameraCfg.onvifSupportF = fieldVal;
                    break;

                case IP_CAMERA_CFG_ONVIF_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipCameraCfg.onvifPort = fieldVal;
                    break;

                case IP_CAMERA_CFG_RTSP_PROTOCOL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    ipCameraCfg.rtspProtocol = fieldVal;
                    break;

                case IP_CAMERA_CFG_MAC_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, ipCameraCfg.macAddr, sizeof(ipCameraCfg.macAddr));
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleIpCameraConfig(indexId, &ipCameraCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defIpCameraCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleIpCameraConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                   NETWORK DEVICE SETTINGS                                   **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getNetworkDeviceCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16                  fieldLoop;
    UINT16                  indexLoop;
    UINT16                  outLen = 0;
    NETWORK_DEVICE_CONFIG_t networkDeviceCfg;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleNetworkDeviceConfig(indexLoop, &networkDeviceCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case NETWORK_DEVICE_CFG_DEVICE_NAME:
                    PRINT_STRING(networkDeviceCfg.deviceName);
                    break;

                case NETWORK_DEVICE_CFG_REGISTER_MODE:
                    PRINT_INT(networkDeviceCfg.registerMode);
                    break;

                case NETWORK_DEVICE_CFG_REGISTER_MODE_ADDRESS:
                    PRINT_STRING(networkDeviceCfg.registerModeAddress);
                    break;

                case NETWORK_DEVICE_CFG_PORT:
                    PRINT_INT(networkDeviceCfg.port);
                    break;

                case NETWORK_DEVICE_CFG_USERNAME:
                    PRINT_STRING(networkDeviceCfg.username);
                    break;

                case NETWORK_DEVICE_CFG_PASSWORD:
                    PRINT_STRING(networkDeviceCfg.password);
                    break;

                case NETWORK_DEVICE_CFG_ENABLE:
                    PRINT_INT(networkDeviceCfg.enable);
                    break;

                case NETWORK_DEVICE_CFG_AUTO_LOGIN:
                    PRINT_INT(networkDeviceCfg.autoLogin);
                    break;

                case NETWORK_DEVICE_CFG_LIVE_STREAM_TYPE:
                    PRINT_INT(networkDeviceCfg.liveStreamType);
                    break;

                case NETWORK_DEVICE_CFG_PREFER_DEV_CREDENTIAL:
                    PRINT_INT(networkDeviceCfg.preferDeviceCredential);
                    break;

                case NETWORK_DEVICE_CFG_FORWARDED_PORT:
                    PRINT_INT(networkDeviceCfg.forwardedTcpPort);
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
		}

		PRINT_EOI;
        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setNetworkDeviceCfg(CHARPTR *reqStr)
{
	NETWORK_DEVICE_CONFIG_t newNetworkDeviceCfg;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId;
	UINT64				fieldId;
	UINT64				fieldVal = 0;


	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_NETWORK_DEVICE_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleNetworkDeviceConfig(indexId, &newNetworkDeviceCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case NETWORK_DEVICE_CFG_DEVICE_NAME:
                    writeStatus = ParseStr(reqStr, FSP, newNetworkDeviceCfg.deviceName, sizeof(newNetworkDeviceCfg.deviceName));
                    break;

                case NETWORK_DEVICE_CFG_REGISTER_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.registerMode = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_REGISTER_MODE_ADDRESS:
                    writeStatus = ParseStr(reqStr, FSP, newNetworkDeviceCfg.registerModeAddress, sizeof(newNetworkDeviceCfg.registerModeAddress));
                    break;

                case NETWORK_DEVICE_CFG_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.port = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, newNetworkDeviceCfg.username, sizeof(newNetworkDeviceCfg.username));
                    break;

                case NETWORK_DEVICE_CFG_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, newNetworkDeviceCfg.password, sizeof(newNetworkDeviceCfg.password));
                    break;

                case NETWORK_DEVICE_CFG_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.enable = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_AUTO_LOGIN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.autoLogin = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_LIVE_STREAM_TYPE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.liveStreamType = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_PREFER_DEV_CREDENTIAL:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.preferDeviceCredential = fieldVal;
                    break;

                case NETWORK_DEVICE_CFG_FORWARDED_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    newNetworkDeviceCfg.forwardedTcpPort = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleNetworkDeviceConfig(indexId, &newNetworkDeviceCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defNetworkDeviceCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleNetwokDeviceConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                     SNAPSHOT SETTINGS                                       **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getSnapshotCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	UINT8					indexLoop;
	SNAPSHOT_CONFIG_t		snapshotCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e	    retVal = CMD_SUCCESS;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleSnapshotConfig(indexLoop, &snapshotCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SNPSHT_UPLD_ENABLE:
                    PRINT_INT(snapshotCfg.snapShotEnable);
                    break;

                case SNPSHT_UPLD_LOCATION:
                    PRINT_INT(snapshotCfg.snapShotuploadLocation);
                    break;

                case SNPSHT_UPLD_EMAIL_ADDR:
                    PRINT_STRING(snapshotCfg.snapShotuploadToEmail.emailAddress);
                    break;

                case SNPSHT_UPLD_EMAIL_SUBJECT:
                    PRINT_STRING(snapshotCfg.snapShotuploadToEmail.subject);
                    break;

                case SNPSHT_UPLD_EMAIL_MESSAGE:
                    PRINT_STRING(snapshotCfg.snapShotuploadToEmail.message);
                    break;

                case SNPSHT_UPLD_RATE:
                    PRINT_INT(snapshotCfg.snapShotuploadImageRate);
                    break;

                case (SNPSHT_UPLD_COPY_TO_CAMERA_START)...(SNPSHT_UPLD_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
		}

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setSnapshotCfg(CHARPTR *reqStr)
{
	SNAPSHOT_CONFIG_t 			snapshotCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
    CAMERA_BIT_MASK_t			copyToCam;
    UINT8						camId = 0;

    memset(&copyToCam, 0, sizeof(copyToCam));
	do
	{
		if((reqStr == NULL) || (*reqStr == NULL))
		{
			retVal = CMD_PROCESS_ERROR;
			break;
		}

		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//Increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SNAPSHOT_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idxId = CLIENT_TO_OUR_INDEX(idxId);
		ReadSingleSnapshotConfig(idxId, &snapshotCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case SNPSHT_UPLD_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr,&val,1,FSP);
                    snapshotCfg.snapShotEnable = val;
                    break;

                case SNPSHT_UPLD_LOCATION:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snapshotCfg.snapShotuploadLocation = val;
                    break;

                case SNPSHT_UPLD_EMAIL_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, snapshotCfg.snapShotuploadToEmail.emailAddress, sizeof(snapshotCfg.snapShotuploadToEmail.emailAddress));
                    break;

                case SNPSHT_UPLD_EMAIL_SUBJECT:
                    writeStatus = ParseStr(reqStr, FSP, snapshotCfg.snapShotuploadToEmail.subject, sizeof(snapshotCfg.snapShotuploadToEmail.subject));
                    break;

                case SNPSHT_UPLD_EMAIL_MESSAGE:
                    writeStatus = ParseStr(reqStr, FSP, snapshotCfg.snapShotuploadToEmail.message, sizeof(snapshotCfg.snapShotuploadToEmail.message));
                    break;

                case SNPSHT_UPLD_RATE:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snapshotCfg.snapShotuploadImageRate = val;
                    break;

                case (SNPSHT_UPLD_COPY_TO_CAMERA_START)...(SNPSHT_UPLD_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    copyToCam.bitMask[fieldId - SNPSHT_UPLD_COPY_TO_CAMERA_START] = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

            if (writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		(*reqStr)++;
        if (writeStatus != SUCCESS)
		{
			break;
		}

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleSnapshotConfig(camId, &snapshotCfg);
                if(retVal != CMD_SUCCESS)
                {
                    break;
                }
            }
        }

	}while(**reqStr != EOT);

    //If reqStr in not NULL then increment
    if((reqStr != NULL) && (*reqStr != NULL))
    {
        (*reqStr)++;
    }
    return retVal;
}

static NET_CMD_STATUS_e defSnapshotCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if (CMD_SUCCESS != DfltSingleSnapshotConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e getSnapshotSchdCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					 	fieldLoop;
	SNAPSHOT_SCHEDULE_CONFIG_t 	snpShtSchdCfg;
	UINT16					 	outLen = 0;
	UINT16 						startIdx;
	NET_CMD_STATUS_e		 	retVal = CMD_SUCCESS;

	for(startIdx = fromIndex; startIdx <= toIndex; startIdx++)
	{
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(startIdx), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

		ReadSingleSnapshotScheduleConfig(startIdx, &snpShtSchdCfg);
		for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
		{
			switch(fieldLoop)
			{
                case SNPSHT_SCHD_RENTIRE_DAY:
                    PRINT_INT(snpShtSchdCfg.dailySanpShotPeriod.recordEntireDay);
                    break;

                case SNPSHT_SCHD_PERIOD0_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[0].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD0_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[0].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD1_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[1].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD1_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[1].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD2_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[2].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD2_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[2].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD3_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[3].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD3_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[3].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD4_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[4].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD4_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[4].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD5_START_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[5].startTime);
                    break;

                case SNPSHT_SCHD_PERIOD5_END_TIME:
                    PRINT_TIME(snpShtSchdCfg.dailySanpShotPeriod.period[5].endTime);
                    break;

                case SNPSHT_SCHD_PERIOD_COPY_TO_WEEKDAYS:
                    PRINT_INT(snpShtSchdCfg.copyToWeekDays);
                    break;

                case (SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_START)...(SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_VALUE;
                    break;
			}

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }

			if(retVal != CMD_SUCCESS)
			{
				break;
			}
        }

        //Validate Buffer size
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c", EOI);
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }

		if(retVal != CMD_SUCCESS)
		{
			break;
		}
	}

	return retVal;
}

static NET_CMD_STATUS_e setSnapshotSchdCfg(CHARPTR *reqStr)
{
	SNAPSHOT_SCHEDULE_CONFIG_t 	snpShtSchdCfg;
	UINT64 						fieldId;
	UINT64 						idxId;
	UINT64 						val = 0;
	NET_CMD_STATUS_e			retVal = CMD_SUCCESS;
	BOOL 						writeStatus = FAIL;
    CAMERA_BIT_MASK_t			copyToCam;
	UINT8						camId = 0;

    memset(&copyToCam, 0, sizeof(copyToCam));
	do
	{
        //Check whether first elemnt is SOI or not and increment address to retrieve next value
		if(**reqStr != SOI)
		{
			retVal = CMD_INVALID_SYNTAX;
			break;
		}

		//increment SOI
		*reqStr = *reqStr + 1;

		//Get Index Id
		if(SUCCESS != ParseStringGetVal(reqStr, &idxId, 1, FSP))
		{
			retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse");
			break;
		}

        if(idxId > (UINT64)totalIndexPerEveryTable[TBL_SNAPSHOT_SCHEDULE_CFG])
		{
			retVal = CMD_INVALID_INDEX_ID;
			break;
		}

		idxId = CLIENT_TO_OUR_INDEX(idxId);
		ReadSingleSnapshotScheduleConfig(idxId, &snpShtSchdCfg);
		while(**reqStr != EOI)
		{
			//Get filed string
			if(SUCCESS != ParseStringGetVal(reqStr, &fieldId, 1, FVS))
			{
				retVal = CMD_INVALID_SYNTAX;
				writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
				break;
			}

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
			{
                case SNPSHT_SCHD_RENTIRE_DAY:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.recordEntireDay = val;
                    break;

                case SNPSHT_SCHD_PERIOD0_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[0].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[0].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD0_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[0].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[0].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD1_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[1].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[1].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD1_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[1].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[1].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD2_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[2].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[2].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD2_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[2].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[2].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD3_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[3].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[3].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD3_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[3].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[3].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD4_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[4].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[4].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD4_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[4].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[4].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD5_START_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[5].startTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[5].startTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD5_END_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.dailySanpShotPeriod.period[5].endTime.hour = val / 100;
                    snpShtSchdCfg.dailySanpShotPeriod.period[5].endTime.minute = val % 100;
                    break;

                case SNPSHT_SCHD_PERIOD_COPY_TO_WEEKDAYS:
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    snpShtSchdCfg.copyToWeekDays = val;
                    break;

                case (SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_START)...(SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &val, 1, FSP);
                    copyToCam.bitMask[fieldId - SNPSHT_SCHD_PERIOD_COPY_TO_CAMERA_START] = val;
                    break;

                default:
                    writeStatus = FAIL;
                    break;
			}

			if(writeStatus != SUCCESS)
			{
				retVal = CMD_INVALID_FIELD_VALUE;
				break;
			}
		}

		(*reqStr)++;
		if(writeStatus != SUCCESS)
		{
			break;
		}

        for(camId = 0; camId < getMaxCameraForCurrentVariant(); camId++)
        {
            if(GET_CAMERA_MASK_BIT(copyToCam, camId))
            {
                retVal = WriteSingleSnapshotScheduleConfig(camId, &snpShtSchdCfg);
                if(retVal != CMD_SUCCESS)
                {
                    break;
                }
            }
        }
    //increment address to retrieve next value
	}while(**reqStr != EOT);

	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defSnapshotSchdCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

	for(indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
	{
        if(CMD_SUCCESS != DfltSingleSnapShotScheduleConfig(indexLoop))
		{
            return CMD_PROCESS_ERROR;
		}
	}

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                    LOGIN POLICY SETTINGS                                    **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getLoginPolicyCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16					fieldLoop;
	LOGIN_POLICY_CONFIG_t 	loginPolicyCfg;
	UINT16					outLen = 0;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;

	ReadLoginPolicyConfig(&loginPolicyCfg);

    //Validate Buffer size for add last two character including NULL
    outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

	for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
	{
		switch(fieldLoop)
		{
            case LOGIN_POLICY_MIN_PASS_CHARCTER:
                PRINT_INT(loginPolicyCfg.minPassLength);
                break;

            case LOGIN_POLICY_PASS_RESET_STATUS:
                PRINT_INT(loginPolicyCfg.passResetStatus);
                break;

            case LOGIN_POLICY_PASS_RESET_PERIOD:
                PRINT_INT(loginPolicyCfg.passResetPeriod);
                break;

            case LOGIN_POLICY_LOCK_ACCOUNT_ATTEMPTS:
                PRINT_INT(loginPolicyCfg.lockAccountStatus);
                break;

            case LOGIN_POLICY_LOCK_ATTEMPTS:
                PRINT_INT(loginPolicyCfg.invalidLoginAttempt);
                break;

            case LOGIN_POLICY_AUTO_UNLOCK_TIMER:
                PRINT_INT(loginPolicyCfg.autoLockTimer);
                break;

            default:
                break;
		}

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
	}

	PRINT_EOI;
	return retVal;
}

static NET_CMD_STATUS_e setLoginPolicyCfg(CHARPTR *reqStr)
{
	LOGIN_POLICY_CONFIG_t 	loginPolicyCfg;
    BOOL					writeStatus = SUCCESS;
	NET_CMD_STATUS_e		retVal = CMD_SUCCESS;
	UINT64					indexId;
	UINT64					fieldId;
	UINT64					fieldVal = 0;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_LOGIN_POLICY_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadLoginPolicyConfig(&loginPolicyCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case LOGIN_POLICY_MIN_PASS_CHARCTER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.minPassLength = (UINT8)fieldVal;
                    break;

                case LOGIN_POLICY_PASS_RESET_STATUS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.passResetStatus = (BOOL)fieldVal;
                    break;

                case LOGIN_POLICY_PASS_RESET_PERIOD:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.passResetPeriod = (UINT16)fieldVal;
                    break;

                case LOGIN_POLICY_LOCK_ACCOUNT_ATTEMPTS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.lockAccountStatus = (LOGIN_LOCK_STATUS_e)fieldVal;
                    break;

                case LOGIN_POLICY_LOCK_ATTEMPTS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.invalidLoginAttempt = (UINT16)fieldVal;
                    break;

                case LOGIN_POLICY_AUTO_UNLOCK_TIMER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    loginPolicyCfg.autoLockTimer = (UINT16)fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteLoginPolicyConfig(&loginPolicyCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
	(*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defLoginPolicyCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltLoginPolicyConfig();
}

/** ******************************************************************************************* **/
/**                                  AUDIO-OUT SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getAudioOutCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
	UINT16				fieldLoop;
	AUDIO_OUT_CONFIG_t	audioOutCfg;
    UINT16				outLen;

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadAudioOutConfig(&audioOutCfg);
    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch(fieldLoop)
        {
            case AUDIO_OUT_CFG:
                PRINT_INT(audioOutCfg.priority);
                break;
        }

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setAudioOutCfg(CHARPTR *reqStr)
{
	AUDIO_OUT_CONFIG_t	audioOutCfg;
    BOOL				writeStatus = SUCCESS;
	NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
	UINT64				indexId;
	UINT64				fieldId;
	UINT64				fieldVal = 0;

	while(**reqStr != EOT)
	{
        if(**reqStr != SOI)
		{
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_AUDIO_OUT_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        ReadAudioOutConfig(&audioOutCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case AUDIO_OUT_CFG:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    audioOutCfg.priority = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteAudioOutConfig(&audioOutCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
	}

	// increment for EOT
    (*reqStr)++;
	return retVal;
}

static NET_CMD_STATUS_e defAudioOutCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltAudioOutConfig();
}

/** ******************************************************************************************* **/
/**                                        P2P SETTINGS                                         **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getP2PCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16				fieldLoop;
    P2P_CONFIG_t        p2pCfg;
    UINT16				outLen;

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadP2PConfig(&p2pCfg);
    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch(fieldLoop)
        {
            case P2P_ENABLE:
                PRINT_INT(p2pCfg.p2pEnable);
                break;

            case P2P_RELAY_SERVER_FALLBACK:
                PRINT_INT(p2pCfg.fallbackToRelayServer);
                break;
        }

        //Validate Buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setP2PCfg(CHARPTR *reqStr)
{
    P2P_CONFIG_t        p2pCfg;
    BOOL				writeStatus = SUCCESS;
    NET_CMD_STATUS_e	retVal = CMD_SUCCESS;
    UINT64				indexId;
    UINT64				fieldId;
    UINT64				fieldVal = 0;

    while(**reqStr != EOT)
    {
        if(**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_P2P_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        ReadP2PConfig(&p2pCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case P2P_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    p2pCfg.p2pEnable = fieldVal;
                    break;

                case P2P_RELAY_SERVER_FALLBACK:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    p2pCfg.fallbackToRelayServer = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteP2PConfig(&p2pCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    // increment for EOT
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defP2PCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltP2PConfig();
}

/** ******************************************************************************************* **/
/**                                       IMAGE SETTINGS                                        **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getImgSettingCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16                  fieldLoop;
    UINT16                  indexLoop;
    UINT16                  outLen = 0;
    IMG_SETTING_CONFIG_t    imgSettingCfg;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        //Validate Buffer size for add last two character including NULL
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        ReadSingleImageSettingConfig(indexLoop, &imgSettingCfg);
        for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
        {
            switch(fieldLoop)
            {
                case IMG_SETTING_BRIGHTNESS:
                    PRINT_INT(imgSettingCfg.brightness);
                    break;

                case IMG_SETTING_CONTRAST:
                    PRINT_INT(imgSettingCfg.contrast);
                    break;

                case IMG_SETTING_SATURATION:
                    PRINT_INT(imgSettingCfg.saturation);
                    break;

                case IMG_SETTING_HUE:
                    PRINT_INT(imgSettingCfg.hue);
                    break;

                case IMG_SETTING_SHARPNESS:
                    PRINT_INT(imgSettingCfg.sharpness);
                    break;

                case IMG_SETTING_WHITE_BALANCE:
                    PRINT_INT(imgSettingCfg.whiteBalanceMode);
                    break;

                case IMG_SETTING_WDR_MODE:
                    PRINT_INT(imgSettingCfg.wdrMode);
                    break;

                case IMG_SETTING_WDR_STRENGTH:
                    PRINT_INT(imgSettingCfg.wdrStrength);
                    break;

                case IMG_SETTING_BACKLIGHT:
                    PRINT_INT(imgSettingCfg.backlightMode);
                    break;

                case IMG_SETTING_EXPOSURE_RATIO_MODE:
                    PRINT_INT(imgSettingCfg.exposureRatioMode);
                    break;

                case IMG_SETTING_EXPOSURE_RATIO:
                    PRINT_INT(imgSettingCfg.exposureRatio);
                    break;

                case IMG_SETTING_EXPOSURE_MODE:
                    PRINT_INT(imgSettingCfg.exposureMode);
                    break;

                case IMG_SETTING_FLICKER:
                    PRINT_INT(imgSettingCfg.flicker);
                    break;

                case IMG_SETTING_FLICKER_STRENGTH:
                    PRINT_INT(imgSettingCfg.flickerStrength);
                    break;

                case IMG_SETTING_HLC:
                    PRINT_INT(imgSettingCfg.hlc);
                    break;

                case IMG_SETTING_EXPOSURE_TIME:
                    PRINT_INT(imgSettingCfg.exposureTime);
                    break;

                case IMG_SETTING_EXPOSURE_GAIN:
                    PRINT_INT(imgSettingCfg.exposureGain);
                    break;

                case IMG_SETTING_EXPOSURE_IRIS:
                    PRINT_INT(imgSettingCfg.exposureIris);
                    break;

                case IMG_SETTING_NORMAL_LIGHT_GAIN:
                    PRINT_INT(imgSettingCfg.normalLightGain);
                    break;

                case IMG_SETTING_NORMAL_LIGHT_LUMINANCE:
                    PRINT_INT(imgSettingCfg.normalLightLuminance);
                    break;

                case IMG_SETTING_LED_MODE:
                    PRINT_INT(imgSettingCfg.irLedMode);
                    break;

                case IMG_SETTING_LED_SENSITIVITY:
                    PRINT_INT(imgSettingCfg.irLedSensitivity);
                    break;

                case (IMG_SETTING_COPY_TO_CAMERA_START)...(IMG_SETTING_COPY_TO_CAMERA_END):
                    PRINT_INT(0);
                    break;

                default:
                    break;
            }

            //Validate Buffer size for add last two character including NULL
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
        }

        PRINT_EOI;
        //Validate Buffer size
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
    }

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setImgSettingCfg(CHARPTR *reqStr)
{
    BOOL                    writeStatus = SUCCESS;
    NET_CMD_STATUS_e        retVal = CMD_SUCCESS;
    UINT64                  indexId;
    UINT64                  fieldId;
    UINT64                  fieldVal = 0;
    IMG_SETTING_CONFIG_t    imgSettingCfg;
    CAMERA_BIT_MASK_t       copyToCamera;

    memset(&copyToCamera, 0, sizeof(copyToCamera));
    while(**reqStr != EOT)
    {
        if(**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // Increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_IMG_SETTING_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleImageSettingConfig(indexId, &imgSettingCfg);

        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case IMG_SETTING_BRIGHTNESS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.brightness = fieldVal;
                    break;

                case IMG_SETTING_CONTRAST:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.contrast = fieldVal;
                    break;

                case IMG_SETTING_SATURATION:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.saturation = fieldVal;
                    break;

                case IMG_SETTING_HUE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.hue = fieldVal;
                    break;

                case IMG_SETTING_SHARPNESS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.sharpness = fieldVal;
                    break;

                case IMG_SETTING_WHITE_BALANCE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.whiteBalanceMode = fieldVal;
                    break;

                case IMG_SETTING_WDR_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.wdrMode = fieldVal;
                    break;

                case IMG_SETTING_WDR_STRENGTH:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.wdrStrength = fieldVal;
                    break;

                case IMG_SETTING_BACKLIGHT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.backlightMode = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_RATIO_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureRatioMode = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_RATIO:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureRatio = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureMode = fieldVal;
                    break;

                case IMG_SETTING_FLICKER:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.flicker = fieldVal;
                    break;

                case IMG_SETTING_FLICKER_STRENGTH:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.flickerStrength = fieldVal;
                    break;

                case IMG_SETTING_HLC:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.hlc = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_TIME:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureTime = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_GAIN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureGain = fieldVal;
                    break;

                case IMG_SETTING_EXPOSURE_IRIS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.exposureIris = fieldVal;
                    break;

                case IMG_SETTING_NORMAL_LIGHT_GAIN:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.normalLightGain = fieldVal;
                    break;

                case IMG_SETTING_NORMAL_LIGHT_LUMINANCE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.normalLightLuminance = fieldVal;
                    break;

                case IMG_SETTING_LED_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.irLedMode = fieldVal;
                    break;

                case IMG_SETTING_LED_SENSITIVITY:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    imgSettingCfg.irLedSensitivity = fieldVal;
                    break;

                case (IMG_SETTING_COPY_TO_CAMERA_START)...(IMG_SETTING_COPY_TO_CAMERA_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    copyToCamera.bitMask[fieldId - IMG_SETTING_COPY_TO_CAMERA_START] = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        CLR_CAMERA_MASK_BIT(copyToCamera, indexId);
        retVal = WriteImageSettingAfterAdjust(indexId, &imgSettingCfg, copyToCamera);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    // increment for EOT
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defImgSettingCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        if (CMD_SUCCESS != DfltSingleImageSettingConfig(indexLoop))
        {
            return CMD_PROCESS_ERROR;
        }
    }

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                       DHCP SERVER                                           **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getDhcpServerCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr,  const UINT32 respStrLen)
{
    DHCP_SERVER_CONFIG_t    dhcpServerCfg;
    UINT16                  fieldLoop;
    UINT16                  outLen;

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadDhcpServerConfig(&dhcpServerCfg);
    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch(fieldLoop)
        {
            case DHCP_SERVER_CFG_ETHERNET_PORT:
                PRINT_INT(dhcpServerCfg.lanPort);
                break;

            case DHCP_SERVER_CFG_ENABLE:
                PRINT_INT(dhcpServerCfg.enable);
                break;

            case DHCP_SERVER_CFG_START_IP_ADDR:
                PRINT_STRING(dhcpServerCfg.startIpAddr);
                break;

            case DHCP_SERVER_CFG_NUMBER_OF_HOSTS:
                PRINT_INT(dhcpServerCfg.noOfHost);
                break;

            case DHCP_SERVER_CFG_GATEWAY:
                PRINT_STRING(dhcpServerCfg.gatewayAddr);
                break;

            case DHCP_SERVER_CFG_DNS_SERVER_ADDR:
                PRINT_STRING(dhcpServerCfg.dnsServerAddr);
                break;

            case DHCP_SERVER_CFG_LEASE_HOURS:
                PRINT_INT(dhcpServerCfg.leaseHour);
                break;

            default:
                break;
        }

        //Validate buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setDhcpServerCfg(CHARPTR *reqStr)
{
    DHCP_SERVER_CONFIG_t    dhcpServerCfg;
    UINT64                  fieldId = 0;
    UINT64                  indexId = 0;
    UINT64                  fieldVal = 0;
    BOOL                    writeStatus = SUCCESS;
    NET_CMD_STATUS_e        retVal = CMD_SUCCESS;

    while (**reqStr != EOT)
    {
        if (**reqStr != SOI)
        {
            //invalid string
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_DHCP_SERVER_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadDhcpServerConfig(&dhcpServerCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case DHCP_SERVER_CFG_ETHERNET_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dhcpServerCfg.lanPort = fieldVal;
                    break;

                case DHCP_SERVER_CFG_ENABLE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dhcpServerCfg.enable = fieldVal;
                    break;

                case DHCP_SERVER_CFG_START_IP_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, dhcpServerCfg.startIpAddr, sizeof(dhcpServerCfg.startIpAddr));
                    break;

                case DHCP_SERVER_CFG_NUMBER_OF_HOSTS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dhcpServerCfg.noOfHost = fieldVal;
                    break;

                case DHCP_SERVER_CFG_GATEWAY:
                    writeStatus = ParseStr(reqStr, FSP, dhcpServerCfg.gatewayAddr, sizeof(dhcpServerCfg.gatewayAddr));
                    break;

                case DHCP_SERVER_CFG_DNS_SERVER_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, dhcpServerCfg.dnsServerAddr, sizeof(dhcpServerCfg.dnsServerAddr));
                    break;

                case DHCP_SERVER_CFG_LEASE_HOURS:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    dhcpServerCfg.leaseHour = fieldVal;
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteDhcpServerConfig(&dhcpServerCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    // increment for EOT
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defDhcpServerCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltDhcpServerConfig();
}

/** ******************************************************************************************* **/
/**                                    FIRMWARE MANAGEMENT                                      **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getFirmwareManagementCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr,  const UINT32 respStrLen)
{
    FIRMWARE_MANAGEMENT_CONFIG_t 	firmwareManagementCfg;
    UINT16                          fieldLoop;
    UINT16                          outLen;

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if(outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadFirmwareManagementConfig(&firmwareManagementCfg);
    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch(fieldLoop)
        {
            case FIRMWARE_MANAGEMENT_CFG_MODE:
                PRINT_INT(firmwareManagementCfg.autoUpgradeMode);
                break;

            case FIRMWARE_MANAGEMENT_CFG_SCHEDULE:
                PRINT_TIME(firmwareManagementCfg.scheduleTime);
                break;

            case FIRMWARE_MANAGEMENT_CFG_FTP_SERVER_TYPE:
                PRINT_INT(firmwareManagementCfg.ftpServerType);
                break;

            case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_ADDR:
                PRINT_STRING(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].server);
                break;

            case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PORT:
                PRINT_INT(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].serverPort);
                break;

            case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_USERNAME:
                PRINT_STRING(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].username);
                break;

            case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PASSWORD:
                PRINT_STRING(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].password);
                break;

            case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PATH:
                PRINT_STRING(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].uploadPath);
                break;

            default:
                break;
        }

        //Validate buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setFirmwareManagementCfg(CHARPTR *reqStr)
{
    FIRMWARE_MANAGEMENT_CONFIG_t    firmwareManagementCfg;
    UINT64                          fieldId = 0;
    UINT64                          indexId = 0;
    UINT64                          fieldVal = 0;
    BOOL                            writeStatus = SUCCESS;
    NET_CMD_STATUS_e                retVal = CMD_SUCCESS;

    while (**reqStr != EOT)
    {
        if (**reqStr != SOI)
        {
            //invalid string
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        //Get Index Id
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_FIRMWARE_MANAGEMENT_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadFirmwareManagementConfig(&firmwareManagementCfg);
        while (**reqStr != EOI)
        {
            // Get field string
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case FIRMWARE_MANAGEMENT_CFG_MODE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    firmwareManagementCfg.autoUpgradeMode = fieldVal;
                    break;

                case FIRMWARE_MANAGEMENT_CFG_SCHEDULE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    firmwareManagementCfg.scheduleTime.minute = fieldVal % 100;
                    firmwareManagementCfg.scheduleTime.hour = fieldVal / 100;
                    break;

                case FIRMWARE_MANAGEMENT_CFG_FTP_SERVER_TYPE:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    firmwareManagementCfg.ftpServerType = fieldVal;
                    break;

                case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_ADDR:
                    writeStatus = ParseStr(reqStr, FSP, firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].server,
                                           sizeof(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].server));
                    break;

                case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PORT:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].serverPort = fieldVal;
                    break;

                case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].username,
                                           sizeof(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].username));
                    break;

                case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PASSWORD:
                    writeStatus = ParseStr(reqStr, FSP, firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].password,
                                           sizeof(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].password));
                    break;

                case FIRMWARE_MANAGEMENT_CFG_CUSTOM_FTP_SERVER_PATH:
                    writeStatus = ParseStr(reqStr, FSP, firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].uploadPath,
                                           sizeof(firmwareManagementCfg.ftpServerInfo[FIRMWARE_FTP_SERVER_CUSTOM].uploadPath));
                    break;

                default:
                    writeStatus = FAIL;
                    retVal = CMD_INVALID_FIELD_ID;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteFirmwareManagementConfig(&firmwareManagementCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    // increment for EOT
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defFirmwareManagementCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltFirmwareManagementConfig();
}

/** ******************************************************************************************* **/
/**                                    FCM PUSH NOTIFICATION                                    **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getFcmPushNotificationCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    FCM_PUSH_NOTIFY_CONFIG_t    fcmPushNotifyCfg;
    UINT16                      fieldLoop;
    UINT16                      outLen;

    //Validate Buffer size for add last two character including NULL
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);

    if (outLen > respStrLen - 2)
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadFcmPushNotifyConfig(&fcmPushNotifyCfg);

    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch (fieldLoop)
        {
            case FCM_PUSH_NOTIFICATION_CFG_USERNAME:
                PRINT_STRING(fcmPushNotifyCfg.username);
                break;

            case FCM_PUSH_NOTIFICATION_CFG_DEV_TOKEN:
                PRINT_STRING(fcmPushNotifyCfg.deviceFcmToken);
                break;

            case FCM_PUSH_NOTIFICATION_CFG_DEV_MODEL_NAME:
                PRINT_STRING(fcmPushNotifyCfg.deviceModelName);
                break;

            default:
                break;
        }

        //Validate buffer size for add last two character including NULL
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setFcmPushNotificationCfg(CHARPTR *reqStr)
{
    FCM_PUSH_NOTIFY_CONFIG_t    fcmPushNotifyCfg;
    BOOL                        writeStatus = SUCCESS;
    NET_CMD_STATUS_e            retVal = CMD_SUCCESS;
    UINT64                      indexId = 0;
    UINT64                      fieldId = 0;

    while(**reqStr != EOT)
    {
        if(**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        // increment for SOI
        (*reqStr)++;

        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            writeStatus = FAIL;
            EPRINT(NETWORK_MANAGER, "fail to parse");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_FCM_PUSH_NOTIFICATION_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            writeStatus = FAIL;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSingleFcmPushNotificationConfig(indexId, &fcmPushNotifyCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);

            switch (fieldId)
            {
                case FCM_PUSH_NOTIFICATION_CFG_USERNAME:
                    writeStatus = ParseStr(reqStr, FSP, fcmPushNotifyCfg.username, sizeof(fcmPushNotifyCfg.username));
                    break;

                case FCM_PUSH_NOTIFICATION_CFG_DEV_TOKEN:
                    writeStatus = ParseStr(reqStr, FSP, fcmPushNotifyCfg.deviceFcmToken, sizeof(fcmPushNotifyCfg.deviceFcmToken));
                    break;

                case FCM_PUSH_NOTIFICATION_CFG_DEV_MODEL_NAME:
                    writeStatus = ParseStr(reqStr, FSP, fcmPushNotifyCfg.deviceModelName, sizeof(fcmPushNotifyCfg.deviceModelName));
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        // increment for EOI
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSingleFcmPushNotificationConfig(indexId, &fcmPushNotifyCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    // increment for EOT
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defFcmPushNotificationCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        if (CMD_SUCCESS != DfltSinglePushNotificationConfig(indexLoop))
        {
            return CMD_PROCESS_ERROR;
        }
    }

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                      PASSWORD RECOVERY                                      **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getPasswordRecoveryCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT16                      fieldLoop;
    UINT16                      indexLoop;
    PASSWORD_RECOVERY_CONFIG_t	pwdRecoveryCfg;
    UINT16                      outLen = 0;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        /* Validate Buffer size for add last two character including NULL */
        outLen += snprintf(respStringPtr + outLen, respStrLen - outLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(indexLoop), FSP);
        if(outLen > respStrLen - 2)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
        }

        ReadSinglePasswordRecoveryConfig(indexLoop, &pwdRecoveryCfg);
        for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
        {
            switch(fieldLoop)
            {
                case PASSWORD_RECOVERY_CFG_EMAIL_ID:
                    PRINT_STRING(pwdRecoveryCfg.emailId);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_1:
                    PRINT_INT(pwdRecoveryCfg.securityQuestionInfo[0].questionId);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_1:
                    PRINT_STRING(pwdRecoveryCfg.securityQuestionInfo[0].answer);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_2:
                    PRINT_INT(pwdRecoveryCfg.securityQuestionInfo[1].questionId);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_2:
                    PRINT_STRING(pwdRecoveryCfg.securityQuestionInfo[1].answer);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_3:
                    PRINT_INT(pwdRecoveryCfg.securityQuestionInfo[2].questionId);
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_3:
                    PRINT_STRING(pwdRecoveryCfg.securityQuestionInfo[2].answer);
                    break;

                default:
                    break;
            }

            /* Validate Buffer size for add last two character including NULL */
            if(outLen > respStrLen - 2)
            {
                EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
                outLen = respStrLen - 2;
                break;
            }
        }

        PRINT_EOI;
        /* Validate Buffer size */
        if(outLen > respStrLen)
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen;
            break;
        }
    }

    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setPasswordRecoveryCfg(CHARPTR *reqStr)
{
    PASSWORD_RECOVERY_CONFIG_t  pwdRecoveryCfg;
    BOOL                        writeStatus = SUCCESS;
    NET_CMD_STATUS_e            retVal = CMD_SUCCESS;
    UINT64                      indexId;
    UINT64                      fieldId;
    UINT64                      fieldVal = 0;

    while(**reqStr != EOT)
    {
        if(**reqStr != SOI)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        /* Increment for SOI */
        (*reqStr)++;
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            EPRINT(NETWORK_MANAGER, "fail to parse field id");
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_PASSWORD_RECOVERY_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        indexId = CLIENT_TO_OUR_INDEX(indexId);
        ReadSinglePasswordRecoveryConfig(indexId, &pwdRecoveryCfg);
        while(**reqStr != EOI)
        {
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch (fieldId)
            {
                case PASSWORD_RECOVERY_CFG_EMAIL_ID:
                    writeStatus = ParseStr(reqStr, FSP, pwdRecoveryCfg.emailId, sizeof(pwdRecoveryCfg.emailId));
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_1:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    pwdRecoveryCfg.securityQuestionInfo[0].questionId = fieldVal;
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_1:
                    writeStatus = ParseStr(reqStr, FSP, pwdRecoveryCfg.securityQuestionInfo[0].answer, sizeof(pwdRecoveryCfg.securityQuestionInfo[0].answer));
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_2:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    pwdRecoveryCfg.securityQuestionInfo[1].questionId = fieldVal;
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_2:
                    writeStatus = ParseStr(reqStr, FSP, pwdRecoveryCfg.securityQuestionInfo[1].answer, sizeof(pwdRecoveryCfg.securityQuestionInfo[1].answer));
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_QUE_ID_3:
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    pwdRecoveryCfg.securityQuestionInfo[2].questionId = fieldVal;
                    break;

                case PASSWORD_RECOVERY_CFG_SEC_ANS_3:
                    writeStatus = ParseStr(reqStr, FSP, pwdRecoveryCfg.securityQuestionInfo[2].answer, sizeof(pwdRecoveryCfg.securityQuestionInfo[2].answer));
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        /* Increment for EOI */
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteSinglePasswordRecoveryConfig(indexId, &pwdRecoveryCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    /* Increment for EOT */
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defPasswordRecoveryCfg(UINT16 fromIndex, UINT16 toIndex)
{
    UINT16 indexLoop;

    for (indexLoop = fromIndex; indexLoop <= toIndex; indexLoop++)
    {
        if (CMD_SUCCESS != DfltSinglePasswordRecoveryConfig(indexLoop))
        {
            return CMD_PROCESS_ERROR;
        }
    }

    return CMD_SUCCESS;
}

/** ******************************************************************************************* **/
/**                                     STORAGE ALLOCATION                                      **/
/** ******************************************************************************************* **/

static NET_CMD_STATUS_e getStorageAllocationCfg(UINT16 fromIndex, UINT16 toIndex, UINT16 fromField, UINT16 toField, CHARPTR respStringPtr, const UINT32 respStrLen)
{
    UINT8                       maskId;
    UINT8                       volGrpId;
    UINT16                      outLen;
    UINT16                      fieldLoop;
    STORAGE_ALLOCATION_CONFIG_t storageAllocationCfg;

    /* Validate Buffer size for add last two character including NULL */
    outLen = snprintf(respStringPtr, respStrLen, "%c%d%c", SOI, OUR_TO_CLIENT_INDEX(fromIndex), FSP);
    if (outLen > (respStrLen - 2))
    {
        EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
        outLen = respStrLen - 2;
    }

    ReadStorageAllocationConfig(&storageAllocationCfg);
    for (fieldLoop = fromField; fieldLoop <= toField; fieldLoop++)
    {
        switch(fieldLoop)
        {
            case (STORAGE_ALLOCATION_VOLUME_MASK_GROUP_START) ... (STORAGE_ALLOCATION_VOLUME_MASK_GROUP_END):
                PRINT_INT(storageAllocationCfg.storageAllocation[fieldLoop].volumeAllocationMask);
                break;

            case (STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) ... (STORAGE_ALLOCATION_CAMERA_MASK_GROUP_END):
                volGrpId = (fieldLoop - STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) / CAMERA_MASK_MAX;
                maskId = (fieldLoop - STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) % CAMERA_MASK_MAX;
                PRINT_INT64(storageAllocationCfg.storageAllocation[volGrpId].cameraAllocationMask.bitMask[maskId]);
                break;

            default:
                break;
        }

        /* Validate buffer size for add last two character including NULL */
        if (outLen > (respStrLen - 2))
        {
            EPRINT(NETWORK_MANAGER, "length is greater than buffer: [outLen=%d]", outLen);
            outLen = respStrLen - 2;
            break;
        }
    }

    PRINT_EOI;
    return CMD_SUCCESS;
}

static NET_CMD_STATUS_e setStorageAllocationCfg(CHARPTR *reqStr)
{
    UINT8                       maskId;
    UINT8                       volGrpId;
    UINT64                      fieldId = 0;
    UINT64                      indexId = 0;
    UINT64                      fieldVal = 0;
    BOOL                        writeStatus = SUCCESS;
    NET_CMD_STATUS_e            retVal = CMD_SUCCESS;
    STORAGE_ALLOCATION_CONFIG_t storageAllocationCfg;

    while (**reqStr != EOT)
    {
        if (**reqStr != SOI)
        {
            /* Invalid start of index */
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        /* Increment for SOI */
        (*reqStr)++;

        /* Get Index Id */
        if (ParseStringGetVal(reqStr, &indexId, 1, FSP) == FAIL)
        {
            retVal = CMD_INVALID_SYNTAX;
            break;
        }

        if (indexId > (UINT64)totalIndexPerEveryTable[TBL_STORAGE_ALLOCATION_CFG])
        {
            retVal = CMD_INVALID_INDEX_ID;
            break;
        }

        ReadStorageAllocationConfig(&storageAllocationCfg);
        while (**reqStr != EOI)
        {
            /* Get field value */
            if (ParseStringGetVal(reqStr, &fieldId, 1, FVS) == FAIL)
            {
                retVal = CMD_INVALID_SYNTAX;
                writeStatus = FAIL;
                EPRINT(NETWORK_MANAGER, "fail to parse field id");
                break;
            }

            fieldId = CLIENT_TO_OUR_INDEX(fieldId);
            switch(fieldId)
            {
                case (STORAGE_ALLOCATION_VOLUME_MASK_GROUP_START) ... (STORAGE_ALLOCATION_VOLUME_MASK_GROUP_END):
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    storageAllocationCfg.storageAllocation[fieldId].volumeAllocationMask = fieldVal;
                    break;

                case (STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) ... (STORAGE_ALLOCATION_CAMERA_MASK_GROUP_END):
                    volGrpId = (fieldId - STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) / CAMERA_MASK_MAX;
                    maskId = (fieldId - STORAGE_ALLOCATION_CAMERA_MASK_GROUP_START) % CAMERA_MASK_MAX;
                    writeStatus = ParseStringGetVal(reqStr, &fieldVal, 1, FSP);
                    storageAllocationCfg.storageAllocation[volGrpId].cameraAllocationMask.bitMask[maskId] = fieldVal;
                    break;

                default:
                    retVal = CMD_INVALID_FIELD_ID;
                    writeStatus = FAIL;
                    break;
            }

            if ((writeStatus == FAIL) && (retVal != CMD_INVALID_FIELD_ID))
            {
                retVal = CMD_INVALID_SYNTAX;
                break;
            }
        }

        /* Increment for EOI */
        (*reqStr)++;
        if (writeStatus == FAIL)
        {
            break;
        }

        retVal = WriteStorageAllocationConfig(&storageAllocationCfg);
        if (retVal != CMD_SUCCESS)
        {
            break;
        }
    }

    /* Increment for EOT */
    (*reqStr)++;
    return retVal;
}

static NET_CMD_STATUS_e defStorageAllocationCfg(UINT16 fromIndex, UINT16 toIndex)
{
    return DfltStorageAllocationConfig();
}

//#################################################################################################
// @END OF FILE
//#################################################################################################
